<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http-go-gin]]></title>
    <url>%2F2019%2F07%2F18%2Fhttp-go-gin%2F</url>
    <content type="text"><![CDATA[1 简介 httpRoute架构非MVC(beego) handler为radix tree结构，GET POST…不同方法为不同树 压缩字母树：自动分裂为新子树 中间件处理：中间件为[]handler中的前几个handler;最后一个handler为响应路径对应的处理方式，中间件函数内添加c.Next()执行下一个hadler函数；链式处理 底层：listenAndServer等均为go底层net/http 2 源码分析Engine 负责路由、中间件等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.// Create an instance of Engine, by using New() or Default()type Engine struct &#123; RouterGroup // Enables automatic redirection if the current route can't be matched but a // handler for the path with (without) the trailing slash exists. // For example if /foo/ is requested but a route only exists for /foo, the // client is redirected to /foo with http status code 301 for GET requests // and 307 for all other request methods. RedirectTrailingSlash bool // If enabled, the router tries to fix the current request path, if no // handle is registered for it. // First superfluous path elements like ../ or // are removed. // Afterwards the router does a case-insensitive lookup of the cleaned path. // If a handle can be found for this route, the router makes a redirection // to the corrected path with status code 301 for GET requests and 307 for // all other request methods. // For example /FOO and /..//Foo could be redirected to /foo. // RedirectTrailingSlash is independent of this option. RedirectFixedPath bool // If enabled, the router checks if another method is allowed for the // current route, if the current request can not be routed. // If this is the case, the request is answered with 'Method Not Allowed' // and HTTP status code 405. // If no other Method is allowed, the request is delegated to the NotFound // handler. HandleMethodNotAllowed bool ForwardedByClientIP bool // #726 #755 If enabled, it will thrust some headers starting with // 'X-AppEngine...' for better integration with that PaaS. AppEngine bool // If enabled, the url.RawPath will be used to find parameters. UseRawPath bool // If true, the path value will be unescaped. // If UseRawPath is false (by default), the UnescapePathValues effectively is true, // as url.Path gonna be used, which is already unescaped. UnescapePathValues bool // Value of 'maxMemory' param that is given to http.Request's ParseMultipartForm // method call. MaxMultipartMemory int64 delims render.Delims secureJsonPrefix string HTMLRender render.HTMLRender FuncMap template.FuncMap allNoRoute HandlersChain allNoMethod HandlersChain noRoute HandlersChain noMethod HandlersChain // 线程安全，维护空闲列表，缓存已分配内存但暂时不用的项方便后续再利用，减少gc及内存分 // 配压力,适合管理一个package中并发对立的client(http request)共享&amp;再利用的临时 // 项， pool可以缓冲分配开销；不适合short-lived object // 此处用于gin.Context缓冲池 pool sync.Pool trees methodTrees&#125;type methodTree struct &#123; method string root *node&#125;type methodTrees []methodTreetype node struct &#123; //path为绝对路径 path string indices string children []*node // handlers为对应path的所有handlers handlers HandlersChain priority uint32 nType nodeType maxParams uint8 wildChild bool&#125;// New returns a new blank Engine instance without any middleware attached.// By default the configuration is:// - RedirectTrailingSlash: true// - RedirectFixedPath: false// - HandleMethodNotAllowed: false// - ForwardedByClientIP: true// - UseRawPath: false// - UnescapePathValues: truefunc New() *Engine &#123; debugPrintWARNINGNew() engine := &amp;Engine&#123; RouterGroup: RouterGroup&#123; Handlers: nil, basePath: "/", root: true, &#125;, FuncMap: template.FuncMap&#123;&#125;, RedirectTrailingSlash: true, RedirectFixedPath: false, HandleMethodNotAllowed: false, ForwardedByClientIP: true, AppEngine: defaultAppEngine, UseRawPath: false, UnescapePathValues: true, MaxMultipartMemory: defaultMultipartMemory, trees: make(methodTrees, 0, 9), delims: render.Delims&#123;Left: "&#123;&#123;", Right: "&#125;&#125;"&#125;, secureJsonPrefix: "while(1);", &#125; engine.RouterGroup.engine = engine engine.pool.New = func() interface&#123;&#125; &#123; return engine.allocateContext() &#125; return engine&#125; golang pool简介 serverHTTP(net/http包handler的实现) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ServeHTTP conforms to the http.Handler interface.func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req // c.index初始化为-1 c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c)&#125;func (engine *Engine) handleHTTPRequest(c *Context) &#123; httpMethod := c.Request.Method path := c.Request.URL.Path unescape := false if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 &#123; path = c.Request.URL.RawPath unescape = engine.UnescapePathValues &#125; // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ &#123; if t[i].method == httpMethod &#123; root := t[i].root // Find route in tree handlers, params, tsr := root.getValue(path, c.Params, unescape) if handlers != nil &#123; c.handlers = handlers c.Params = params // 执行handlerChain，即中间件及实际处理 c.Next() // 写回conn返回http结果 c.writermem.WriteHeaderNow() return &#125; if httpMethod != "CONNECT" &amp;&amp; path != "/" &#123; if tsr &amp;&amp; engine.RedirectTrailingSlash &#123; redirectTrailingSlash(c) return &#125; if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) &#123; return &#125; &#125; break &#125; &#125; if engine.HandleMethodNotAllowed &#123; for _, tree := range engine.trees &#123; if tree.method != httpMethod &#123; if handlers, _, _ := tree.root.getValue(path, nil, unescape); handlers != nil &#123; c.handlers = engine.allNoMethod serveError(c, 405, default405Body) return &#125; &#125; &#125; &#125; c.handlers = engine.allNoRoute serveError(c, 404, default404Body)&#125; RouteGroup gin可以设置路由组，所有路由组下路由绝对路径为RouteGroup.basePath+relativePath; 中间件：路由组下所有路由的中间件为路由本身中间件+路由组中间件 Handlers即为路由组相应中间件，最后一个可为具体请求处理 新建routeGroup中的engine为原engine的地址一致 engine中的trees为完整的路由树，routeGrouop方便按组添加中间件及某一路径下多子路径添加 12345678910111213141516171819202122// RouterGroup is used internally to configure router, a RouterGroup is associated with a prefix// and an array of handlers (middleware).type RouterGroup struct &#123; Handlers HandlersChain basePath string engine *Engine root bool&#125;// handlerFun定义type HandlerFunc func(*Context)// 组下添加handlerfunc (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes &#123; absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj()&#125;// Use adds middleware to the group, see example code in github.func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes &#123; group.Handlers = append(group.Handlers, middleware...) return group.returnObj()&#125; 每个路径还可以单独添加自己独有的中间件,通过(RouteGroup.Handle): 1234567// handlers可以添加某个relativePath独有的中间件，最终该path的中间件为其所在组的group.handlers+输入参数handlersfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes &#123; if matches, err := regexp.MatchString("^[A-Z]+$", httpMethod); !matches || err != nil &#123; panic("http method " + httpMethod + " is not valid") &#125; return group.handle(httpMethod, relativePath, handlers)&#125; 创建新的routeGroup: 123456789// Group creates a new router group. You should add all the routes that have common middlwares or the same path prefix.// For example, all the routes that use a common middlware for authorization could be grouped.func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup &#123; return &amp;RouterGroup&#123; Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, &#125;&#125; GIN Context listen建立accept后，针对每个请求执行handler时新建gin.Context httpReq项:通过query postfrom bind等方法解析 1234567891011121314151617181920212223242526272829303132333435363738394041// Param returns the value of the URL param.// It is a shortcut for c.Params.ByName(key)// router.GET("/user/:id", func(c *gin.Context) &#123;// // a GET request to /user/john// id := c.Param("id") // id == "john"// &#125;)func (c *Context) Param(key string) string &#123; return c.Params.ByName(key)&#125;// Bind checks the Content-Type to select a binding engine automatically,// Depending the "Content-Type" header different bindings are used:// "application/json" --&gt; JSON binding// "application/xml" --&gt; XML binding// otherwise --&gt; returns an error.// It parses the request's body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.// It decodes the json payload into the struct specified as a pointer.// It writes a 400 error and sets Content-Type header "text/plain" in the response if input is not valid.func (c *Context) Bind(obj interface&#123;&#125;) error &#123; b := binding.Default(c.Request.Method, c.ContentType()) return c.MustBindWith(obj, b)&#125;// Default returns the appropriate Binding instance based on the HTTP method// and the content type.// 根据context-type选择不同的解析engine(不同接口实现)func Default(method, contentType string) Binding &#123; if method == "GET" &#123; return Form &#125; switch contentType &#123; case MIMEJSON: return JSON case MIMEXML, MIMEXML2: return XML case MIMEPROTOBUF: return ProtoBuf case MIMEMSGPACK, MIMEMSGPACK2: return MsgPack default: //case MIMEPOSTForm, MIMEMultipartPOSTForm: return Form &#125;&#125; http1串行处理一个连接的http request 通过net/http包的response结构体实现net/http包的ResponseWriter接口，原生net/http包读到request请求后建立response结构体 server函数处理request请求时调用serverhandler.ServerHTTP方法，其中responseWriter接口的实现为(c *conn)readRequest返回的response结构体 123456789101112// Serve a new connection.func (c *conn) serve(ctx context.Context) &#123; ...省略 // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all // process in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) ...省略&#125; 处理http请求，获取请求 返回结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Read next request from connection.func (c *conn) readRequest(ctx context.Context) (w *response, err error) &#123; if c.hijacked() &#123; return nil, ErrHijacked &#125; var ( wholeReqDeadline time.Time // or zero if none hdrDeadline time.Time // or zero if none ) t0 := time.Now() if d := c.server.readHeaderTimeout(); d != 0 &#123; hdrDeadline = t0.Add(d) &#125; if d := c.server.ReadTimeout; d != 0 &#123; wholeReqDeadline = t0.Add(d) &#125; c.rwc.SetReadDeadline(hdrDeadline) if d := c.server.WriteTimeout; d != 0 &#123; defer func() &#123; c.rwc.SetWriteDeadline(time.Now().Add(d)) &#125;() &#125; c.r.setReadLimit(c.server.initialReadLimitSize()) if c.lastMethod == "POST" &#123; // RFC 7230 section 3 tolerance for old buggy clients. peek, _ := c.bufr.Peek(4) // ReadRequest will get err below c.bufr.Discard(numLeadingCRorLF(peek)) &#125; req, err := readRequest(c.bufr, keepHostHeader) if err != nil &#123; if c.r.hitReadLimit() &#123; return nil, errTooLarge &#125; return nil, err &#125; if !http1ServerSupportsRequest(req) &#123; return nil, badRequestError("unsupported protocol version") &#125; c.lastMethod = req.Method c.r.setInfiniteReadLimit() hosts, haveHost := req.Header["Host"] isH2Upgrade := req.isH2Upgrade() if req.ProtoAtLeast(1, 1) &amp;&amp; (!haveHost || len(hosts) == 0) &amp;&amp; !isH2Upgrade &amp;&amp; req.Method != "CONNECT" &#123; return nil, badRequestError("missing required Host header") &#125; if len(hosts) &gt; 1 &#123; return nil, badRequestError("too many Host headers") &#125; if len(hosts) == 1 &amp;&amp; !httpguts.ValidHostHeader(hosts[0]) &#123; return nil, badRequestError("malformed Host header") &#125; for k, vv := range req.Header &#123; if !httpguts.ValidHeaderFieldName(k) &#123; return nil, badRequestError("invalid header name") &#125; for _, v := range vv &#123; if !httpguts.ValidHeaderFieldValue(v) &#123; return nil, badRequestError("invalid header value") &#125; &#125; &#125; delete(req.Header, "Host") ctx, cancelCtx := context.WithCancel(ctx) req.ctx = ctx req.RemoteAddr = c.remoteAddr req.TLS = c.tlsState if body, ok := req.Body.(*body); ok &#123; body.doEarlyClose = true &#125; // Adjust the read deadline if necessary. if !hdrDeadline.Equal(wholeReqDeadline) &#123; c.rwc.SetReadDeadline(wholeReqDeadline) &#125; // ***建立response*** // 通过(c conn)server中serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)实现ResponseWriter接口 // http1.1非并发处理一个连接的请求，http2.0实现，http2.0使用不够广泛 w = &amp;response&#123; conn: c, cancelCtx: cancelCtx, req: req, reqBody: req.Body, handlerHeader: make(Header), contentLength: -1, closeNotifyCh: make(chan bool, 1), // We populate these ahead of time so we're not // reading from req.Header after their Handler starts // and maybe mutates it (Issue 14940) wants10KeepAlive: req.wantsHttp10KeepAlive(), wantsClose: req.wantsClose(), &#125; if isH2Upgrade &#123; w.closeAfterReply = true &#125; w.cw.res = w w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize) return w, nil&#125; context存放httpReq获取的请求参数及responseWrite将返回结果返回请求方 12345678910111213141516171819// Context is the most important part of gin. It allows us to pass variables between middleware,// manage the flow, validate the JSON of a request and render a JSON response for example.type Context struct &#123; writermem responseWriter Request *http.Request Writer ResponseWriter // 存储url参数 Params Params handlers HandlersChain index int8 engine *Engine // Keys is a key/value pair exclusively for the context of each request. // 可以通过set/get方法设置及获取keys Keys map[string]interface&#123;&#125; // Errors is a list of errors attached to all the handlers/middlewares who used this context. Errors errorMsgs // Accepted defines a list of manually accepted formats for content negotiation. Accepted []string&#125; context的初始化reset,从poll中取出后reset 12345678910func (c *Context) reset() &#123; c.Writer = &amp;c.writermem c.Params = c.Params[0:0] c.handlers = nil // index初始化为-1 c.index = -1 c.Keys = nil c.Errors = c.Errors[0:0] c.Accepted = nil&#125; 不同goroutine引用context时需要copy context副本，保证并发安全 12345678910// Copy returns a copy of the current context that can be safely used outside the request's scope.// This has to be used when the context has to be passed to a goroutine.func (c *Context) Copy() *Context &#123; var cp = *c cp.writermem.ResponseWriter = nil cp.Writer = &amp;cp.writermem cp.index = abortIndex cp.handlers = nil return &amp;cp&#125; 获取主handler 1234// Handler returns the main handler.func (c *Context) Handler() HandlerFunc &#123; return c.handlers.Last()&#125; context的next处理 123456789// Next should be used only inside middleware.// It executes the pending handlers in the chain inside the calling handler.// See example in GitHub.func (c *Context) Next() &#123; c.index++ for s := int8(len(c.handlers)); c.index &lt; s; c.index++ &#123; c.handlers[c.index](c) &#125;&#125; recover中间件示例 123456789101112131415161718192021222324252627282930313233// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.func Recovery() HandlerFunc &#123; return RecoveryWithWriter(DefaultErrorWriter)&#125;// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.func RecoveryWithWriter(out io.Writer) HandlerFunc &#123; var logger *log.Logger if out != nil &#123; logger = log.New(out, "\n\n\x1b[31m", log.LstdFlags) &#125; return func(c *Context) &#123; defer func() &#123; if err := recover(); err != nil &#123; if logger != nil &#123; stack := stack(3) httprequest, _ := httputil.DumpRequest(c.Request, false) logger.Printf("[Recovery] %s panic recovered:\n%s\n%s\n%s%s", timeFormat(time.Now()), string(httprequest), err, stack, reset) &#125; c.AbortWithStatus(500) &#125; &#125;() // 链式处理handler c.Next() &#125;&#125;// 中断handlers链式处理// Abort prevents pending handlers from being called. Note that this will not stop the current handler.// Let's say you have an authorization middleware that validates that the current request is authorized.// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers// for this request are not called.func (c *Context) Abort() &#123; c.index = abortIndex&#125; http response不同返回类型render处理&amp;&amp;设置cookie 123456789101112131415161718192021222324252627282930313233343536373839404142func (c *Context) Render(code int, r render.Render) &#123; c.Status(code) if !bodyAllowedForStatus(code) &#123; r.WriteContentType(c.Writer) c.Writer.WriteHeaderNow() return &#125; if err := r.Render(c.Writer); err != nil &#123; panic(err) &#125;&#125;// HTML renders the HTTP template specified by its file name.// It also updates the HTTP code and sets the Content-Type as "text/html".// See http://golang.org/doc/articles/wiki/func (c *Context) HTML(code int, name string, obj interface&#123;&#125;) &#123; // 获取render实现 instance := c.engine.HTMLRender.Instance(name, obj) // render返回结果 c.Render(code, instance)&#125;// render接口type Render interface &#123; Render(http.ResponseWriter) error WriteContentType(w http.ResponseWriter)&#125;// render枚举实现var ( _ Render = JSON&#123;&#125; _ Render = IndentedJSON&#123;&#125; _ Render = SecureJSON&#123;&#125; _ Render = JsonpJSON&#123;&#125; _ Render = XML&#123;&#125; _ Render = String&#123;&#125; _ Render = Redirect&#123;&#125; _ Render = Data&#123;&#125; _ Render = HTML&#123;&#125; _ HTMLRender = HTMLDebug&#123;&#125; _ HTMLRender = HTMLProduction&#123;&#125; _ Render = YAML&#123;&#125; _ Render = MsgPack&#123;&#125; _ Render = Reader&#123;&#125;)]]></content>
      <categories>
        <category>网络框架</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理服务注册服务发现]]></title>
    <url>%2F2019%2F07%2F04%2F%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1 服务注册 服务自动将自己的ip地址及其他信息(rpc:serviceName/methodName)等注册到对应的注册中心(etcd zookeeper) 注册中心(zookeeper)可以发送健康检查检查服务的运行状态，进行相应的处理 2 服务发现 cli端(dubbo的consumer)或者proxy代理通过注册中心(etcd zookeeper)等，查询对应的请求对应的ip地址，返回ip地址给cli端 3 代理&amp;&amp;网关 代理根据相应的url命名，解析url转发至相应的服务 eg http请求grpc服务: http请求代理地址，代理服务器到注册中心查询相应serviceName的ip地址，代理服务器做负载均衡，代理服务器将解析的http请求封装成grpc请求，直接请求grpc服务 网关类似代理，所有请求按相应的规则打到网关服务器，网关根据规则将请求转发到对应的服务器或者代理，再做其他处理 kong]]></content>
      <tags>
        <tag>服务注册</tag>
        <tag>服务发现</tag>
        <tag>自动代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go依赖管理]]></title>
    <url>%2F2019%2F07%2F03%2Fgo%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 vendor2 dep3 mod 相同项目依赖不同主版本为不同的文件目录: eg rsc.io/quote 其v3版本与v2版本为不同的文件夹； 相同依赖的主版本不能相同: v1.5.2不能与v1.6.0同时存在 mod支持相同依赖（eg rsc.io/quote）的不同主版本 it is impossible for a program to build with both rsc.io/quote v1.5.2 and rsc.io/quote v1.6.0 go mod init packagename: creates a new module, initializing the go.mod file that describes it. go build, go test, and other package-building commands add new dependencies to go.mod as needed. go list -m all : prints the current module’s dependencies. go get(可带版本): changes the required version of a dependency (or adds a new dependency). go get XX@v1.2.3 go mod tidy : removes unused dependencies.官网参考go.modgo module in 2019依赖包失败解决方案]]></content>
      <tags>
        <tag>go</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os]]></title>
    <url>%2F2019%2F07%2F02%2Fos%2F</url>
    <content type="text"><![CDATA[1 unix基础及标准1.1 体系结构 内核：控制计算机硬件资源，提供程序运行环境 系统调用：内核接口 应用程序：直接调用内核||通过库函数调用内核||通过shell程序 shell：特殊应用程序为其他应用程序提供接口；命令行解释器：读取用户输入然后执行命令； 其他 1.2 login 口令文件: /etc/passwd文件 文件内容为7个以冒号分割的字段即：”登陆名:加密口令:数字用户ID:数字组ID:注释字段:起始目录:shell程序”, eg: “sar:x:205:105:Stephen Rago:/home/sar/:/bin/ksh” 用户登陆后：a 系统显示系统消息； b 某些系统启动视窗管理程序，最终shell程序运行在视窗中； c 用户向shell程序键入命令 1.3 文件和目录 unix文件和目录为层次结构起始为:”/“ 目录：包含目录项的文件,包含一个文件名及文件属性； 文件属性：文件类型(普通文件,目录)、文件大小、文件所有者、文件权限、文件最后修改时间等 stat、fstat:返回文件属性信息 创建目录自动创建两个文件名:. .. ls命令：遍历相应目录文件，获取记录输出记录的文件名 工作目录：每个进程均有工作目录，可以通过chdir更改工作目录 起始工作目录：login时从口令文件中获取，参考 1.2 login 每个文件均包括：所有者的用户ID及组ID 1.4 输入&amp;&amp;输出 文件描述符：非负小整数，内核标识一个进程正在访问的文件 stdin stdout stderr 不带缓冲IO(系统调用)：open read write lseek close 标准IO(库函数)：提供带缓冲接口，调用方不用关心buffSize的选取, eg printf 1.5 程序&amp;&amp;进程 程序：磁盘上可执行文件 进程：程序执行实例，进程ID唯一标识 进程存在进程所有者用户ID及组ID 进程控制: fork exec waitpid 线程: 线程ID，一个进程的所有线程共享同一地址空间、文件描述符、栈及与进程相关属性；线程访问共享数据需要做同步处理； 1.6 出错处理 返回负值设置errno 不同的线程有自己局部errno 致命错误：输出错误并退出 非致命错误：妥善处理，资源类错误可延迟重试，eg EAGAIN ENFILE ENOBUFS ENOLCK ENOSPC EWOULDBLOCK等 1.7 用户标识(用于权限控制) 用户ID：login时获取系统管理员登陆时分配(/etc/passwd文件)，唯一，用户不可更改，0位根用户或超级用户 组ID: login时获取，(/etc/group文件) 附属组ID:用户可以配置多个附属组作权限控制，大多系统最多16个(/etc/group文件) 1.8 信号 系统通知进程发生了某种情况：除0发送SIGFPE信号 信号处理：a 忽略； b 系统默认处理方式; c 捕获信号，提供函数信号发生时调用 产生信号：终端中断键del或ctrl+c，退出键ctrl+\，调用kill函数（向进程发送信号必须是进程所有者或者超级用户) 捕获信号：发送信号到进程(系统设置进程的信号位)-&gt;内核在用户进程栈新建信号处理函数栈，进程从内核态转为用户态时执行信号处理函数，并接着信号中断处继续执行进程 信号机制参考alarm信号 1.9 时间值 日历时间：协调世界时间(Coordinated Universal Time, UTC)1970/01/01 00:00:00后秒数累计，记录文件最近一次修改时间; 进程时间：时钟滴答，cpu时间，度量进程使用的cpu时间，每秒曾取50、60或者100个时钟滴答 进程时间：时钟时间(墙上时钟时间wall clock time，进程运行的总时间)、用户时间（执行用户指令所用时间）、系统时间 1.10 系统调用和库函数 库函数封装系统调用，提供更复杂功能，系统调用提供一种最小接口； eg sbrk为进程分配空间，地址空间管理由进程处理，内核中系统调用分配一块空间给进程，库函数malloc在用户层次管理进程的内存空间; 1.11 标准 ISO C 规定了标准 C 的接口 POSIX 规定了Unix 系统的系统调用以及库函数， 还包括使用程序接口等 SUS(Single Unix Specification（SUS， 单一 Unix 规范) 规定了一些附加接口，扩展了POSIX 程序限制 某些限制在一个给定的 UNIX 实现中可能是固定的（由头文件定义），在另一个 UNIX 实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制：1、编译时限制（由头文件给定）2、与文件或者目录无关的运行时限制（由 sysconf函数给定）:每个进程最大打开文件数，每个用户最大可用进程数，3、与文件或者目录相关的运行时限制（由 pathconf函数以及fpathconf函数给定） 123long sysconf(int name); long pathconf(const char*pathname,int name); long fpathconf(int fd,int name); //fd 为文件描述符 eg: linux系统通过ulimit -a命令查看相关限制ulimit -acore file size (blocks, -c) unlimiteddata seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 450642max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1048576pipe size (512 bytes, -p) 8 //管道缓冲区大小POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192 //线程栈大小cpu time (seconds, -t) unlimitedmax user processes (-u) 1048576virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimitedlinux系统限制及设置：线程数 文件数 2 I/O管理和磁盘调度2.1 概述（不分系统）2.1.1 基本概念 直接储存器访问DMA: 磁盘性能远低于内存及cpu 无I/O缓冲：磁盘通过操作系统读入用户进程空间，若用户进程空间内存正在进行I/O则相应内存不可换出（I/O时进程处于堵塞状态，内存不足时或者新进程调度时可能会换出内存）；若进程在相应内存锁定之前换出内存，则造成进程死锁（进程等待i/o执行激活状态，但相应内存已缓冲无法进行i/o操作) ![I/O层次结构](../pic/os/IO架构体系.png) I/O缓冲：系统开辟空间作为缓冲区，磁盘读入缓冲区，用户进程从系统缓冲区读入，进程调度时不影响进程的换入换出 缓冲区在内核空间，不影响系统对用户进程执行换入换出，不会造成死锁 磁盘性能：排队时间、等待I/O通道、寻道时间、旋转延迟、传送时间 寻道时间：Ts平均小于10ms 旋转延迟：1/2r 传送时间: b/(rN)， b要传送字节数，N一个磁道中字节数，r转速 总平均存取时间: Ts + 1/(2r) + b/(rN) 顺序读取较随机读取快 磁盘调度策略（尽可能顺序读取但又尽量公平）: FIFO SSTF(最短服务时间优先) SCAN(电梯算法：磁头臂仅沿一个方向移动并在途中满足所有未完成请求直到达到最后一个磁道或者没有请求；Look策略会接着反转扫描) C-SCAN（扫描策略仅在一个方向，扫描到末端后，磁头臂返回到末端反方向的末端，减少新请求的等待时间） RAID磁盘阵列+冗余 磁盘高速缓存(单独内存区作缓存):页面置换策略 最不常用(LFU) 最近最少使用(LRU）基于频率置换（新区 老区 &amp;&amp; 新区 中间区 老区；只置换老区最少使用;新区时间过期换到中间区或者老区) 待用参考：linux系统I/O分析cpu、mem、网络I/O、磁盘I/O速度对比 2.1.2 文件系统 域：域名 值 长度 域组成记录，记录组成文件，文件组成数据库 文件系统软件架构缺图 a 设备驱动程序：直接与外围设备（或他们的控制器）通信b 基本文件系统/物理I/O: 操作系统的一部分、外部环境的基本接口、关注块在二级存储和内存缓冲区的位置，不关注数据内容或文件结构c 基本I/O管理程序:负责所有文件的I/O初始和终止、操作系统的一部分、维护设备输入输出、调度、文件状态，根据文件类型执行文件I/O设备，参与磁盘调度、I/O缓冲区的指定和辅存的分配d 逻辑I/O：用户和应用程序能够访问到记录 文件管理的要素： 用户-&gt;目录管理-&gt;文件结构-&gt;访问方法文件操作类型-&gt;记录-&gt;组/块-&gt;内存缓冲区物理块-&gt;辅存中的物理块；缺图 常用文件组织 堆：最简单，数据按顺序到达，记录可以有不同的域，或域相似顺序不同，每个域自描述(域名:值)，域之间用划分符隐士指定或者包含在域中，或者为域类型默认长度；穷举查找，数据难以组织用堆文件；顺序文件（类mysql表）：记录格式完全统一，每个域的域名和长度为文件结构的属性；记录按关键域顺序存储，文本关键域按字母顺序，数字关键域按数字顺序；记录的第一个域通常为关键域，顺序扫描；物理组织对应文件的组织；查找更新性能差，通常存在日志文件或者事务文件，新记录放在堆文件，周期执行成批更新将新纪录合并至主文件并按照正确关键字顺序产生新文件；索引顺序文件：克服顺序文件缺点，保留顺序文件关键特征，快速接近目标，增加了文件索引及溢出文件，溢出文件类似日志堆文件；文件索引帮助快速定位记录：一级索引文件为顺序文件，存记录关键域及主文件中的位置；按索引查询定位到关键域等于或者小于需求关键域的最大值，之后顺序扫描主文件；多级索引加快文件查询速度；索引文件：多索引结构，每种可能成为查询条件的域都有一个索引，无顺序性和关键字概念，只能通过索引访问记录；记录位置无限制，可用变长记录；主文件增加记录，索引全部更新；用于查询及时性高很少对所有数据进行处理的应用程序中：公司订票系统；直接文件/散列文件：直接访问磁盘中任何一个地址已知块，每条记录存在关键域，无顺序排序，基于关键字散列，记录定长；类似散列表 记录组块二级储存管理空闲空间管理 块在扇区，块大小选择可能留下扇区空间，利用不足块大小选择，块是否可变，块越大顺序读取局部性等好，但需要较大的内存缓冲区.文件多条记录储存在物理磁盘块上，给定块大小存在三种组块方式：固定组块(固定长度记录，块末尾可能存在未用空间成为内部碎片);可变长度跨越式组块：可变长度记录，紧缩至块中，记录可以跨越组块；可变长度非跨越式组块：可变长度记录，记录不跨块，大多数块中存在未用空间；文件的块分配，文件分配表：分区大小，可变大规模连续分区、按块分配首次适配、最佳适配、最近适配（一个文件的不同块尽可能靠近）分配方法：预分配、动态分配连续分配（起始块 长度或块总数）、链接分配（起始块 长度，每个块都会链接下一个块）、索引分配（文件名-&gt;索引块，索引块中为文件对应块的列表）&amp;可变分区索引分配（列表为起始块&amp;&amp;块大小）.空闲空间管理：需要磁盘分配表.位表每个位代表相应块，0 1标识是否空间，空间占用小，可完全放入内存链接空闲区、索引（空闲去当作文件)空闲块列表：磁盘保留区为所有空闲块的顺序号，相比较位分配空间占用大，单可以作为栈结构部分导入内存，分配块从栈顶取，释放入栈，若栈空或者栈满则与磁盘交互；（栈可替换为fifo队列）卷为磁盘扇区集合，扇区可不连续文件：基本信息（名 类型 组织）；地址信息（卷 起始地址 使用大小 分配大小）；访问信息控制（所有者 访问信息 权限控制）；使用信息（数据创建 创建者身份 修改时间 当前使用等) 2.2 select&amp;poll&amp;epoll select与poll返回可用的数目，及fd_set bit或者结构体，用户遍历获取可用的fd进行相关处理 select与poll若总链接数百万级以上但活跃数几百，用户需要每次遍历返回结果确定可用的fd浪费cpu select用32个整数的32位，即32*32= 1024来标识，fd值为1-1024，select存在最大数量限制 poll用数组标识无最大fd限制 select用bit标识，返回值会覆盖需要观测的fd位，每次select时均需要初始化 poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。 epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持 select与poll每次调用均需要将fd_set从用户空间copy到内核空间 epoll：用户通过epoll_ctl注册fd_set及监听类型；epoll_wait堵塞直到超时、信号或者可用fd返回，；无最大数量限制 epoll仅返回可用的fd，对返回的fd进行遍历不会浪费cpu select 和 poll 都是主動輪詢機制，需要拜訪每一個 FD； epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，epoll_wait的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。 参考epoll函数linuxepoll函数解析epoll用法epoll内核实现 3 进程&amp;&amp;线程&amp;&amp;IPC3.1 IPC&amp;&amp;跳转 sigsetjmp,siglongjmp的使用 sigsetjmp()会保存目前堆栈环境，然后将目前的地址作一个记号，而在程序其他地方调用siglongjmp()时便会直接跳到这个记号位置，然后还原堆栈，继续程序好执行。 参数savesigs若为非0则代表搁置的信号集合也会一块保存 当sigsetjmp()返回0时代表已经做好记号上，若返回非0则代表由siglongjmp（）跳转回来。 返回值：返回0代表局促存好目前的堆栈环境，随时可供siglongjmp()调用， 若返回非0值则代表由siglongjmp()返回 eg: alarm信号处理函数调用siglongjump,主程序中某个位置调用sigsetjump，若发生alarm信号则siglongjump自动跳回至sigsetjump函数处并恢复sigsetjump函数保存的堆栈信息，同时sigsetjump返回值非0，此时表明已经发生了超时信号则退出主程序]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2019%2F06%2F29%2Fjava%2F</url>
    <content type="text"><![CDATA[java参数传递 vs c++引用 vs go指针传递 c++引用 引用 引用不可为空，对象必须存在不可为null 地址概念：某块内存的别名 引用是别名，地址不可更改 引用使用无需解引*，对引用的赋值为对地址变量的赋值 sizeof引用为引用指向的对象的大小 i 123int j = 6; int &amp;k = i; k = j; // k 和i 的值都变成了6; java引用 引用 值传递 所有的参数传递都是 传值，从来没有 传引用 这个事实； 所有的参数传递都会在 程序运行栈上 新分配一个 值 的复制品； java只有按值传递，所谓的按地址(引用)传递，也属于按值传递，只不过这个“值”是个地址; 对于引用类型的传参也是传值的，传的是引用类型的值，其实就是对象的地址； java所有对像变量都是对像的引用； 函数的形式参数，是传入参数的拷贝；引用变量之间拷贝的是【地址】，基本变量之间拷贝的是 内存中的值 （被称为直接量）； class Test1123456789101112131415&#123; String a = &quot;123&quot;; public static void test(Test1 test) &#123; test.a = &quot;abc&quot;;//更改test指向的内存空间的值 &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(); test1.a = &quot;567&quot;; System.out.println(test1.a); //567 test(test1);//复制test1的地址至test System.out.println(test1.a); //abc &#125;&#125; java引用可以改变引用的地址，java引用.为对引用地址所指向对象的操作，=表示对引用本身的修改（地址) class Test1234567891011121314&#123; public static void test(StringBuffer str) &#123; str.append(&quot;world&quot;);//改变引用对象的内存空间的值 str = new StringBuffer(&quot;world&quot;);//更新地址，并对地址对象赋值，不会改变原值 &#125; public static void main(String[] args) &#123; StringBuffer str = new StringBuffer(&quot;hello&quot;); System.out.println(str); //hello test(str);//复制地址 System.out.println(str); //注释掉str.append为hello，否则为hello world &#125;&#125; 参考1: java参数传递参考2: java堆栈 go(c语言)指针传递 类似C语言，函数传值一切皆copy 参数为指针则为指针所指向的地址的值copy main12345678910111213141516171819202122import ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello, playground&quot;) var a int = 1 b := &amp;a fmt.Println(&quot;the addr of b: &quot;,&amp;b, &quot;, a: &quot;, &amp;a, &quot; value of b: &quot;, b, &quot;the value of *b: &quot;, *b) fun1(b) fmt.Println(&quot;2st the addr of b: &quot;,&amp;b, &quot;, a: &quot;, &amp;a, &quot; value of b: &quot;, b, &quot;the value of *b: &quot;, *b) &#125;func fun1(c *int)&#123;fmt.Println(&quot;the add of c: &quot;, &amp;c, &quot;the value of c: &quot;, c, &quot;the value of *c: &quot;, *c)var d int = 2c = &amp;dfmt.Println(&quot;2 st the add of c: &quot;, &amp;c, &quot;the value of c: &quot;, c, &quot;the value of *c: &quot;, *c)&#125; Hello, playgroundthe addr of b: 0x40c130 , a: 0x414020 value of b: 0x414020 the value of *b: 1 the add of c: 0x40c138 the value of c: 0x414020 the value of *c: 1 2 st the add of c: 0x40c138 the value of c: 0x41402c the value of *c: 2 2st the addr of b: 0x40c130 , a: 0x414020 value of b: 0x414020 the value of *b: 1 传map main123456789101112131415161718192021222324import ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello, playground&quot;) a := make(map[int]int) a[1]=3 fmt.Printf(&quot;1st a[1] is: %d addr of map:%p \n&quot;, a[1],&amp;a) fun1(a) fmt.Printf(&quot;1st a[1] is: %d addr of map:%p \n&quot;, a[1],&amp;a) &#125;func fun1(c map[int]int)&#123;fmt.Printf(&quot;1st c[1] is: %d addr of map:%p \n&quot;, c[1],&amp;c)c=make(map[int]int)c[1]=4fmt.Printf(&quot;1st c[1] is: %d addr of map:%p \n&quot;, c[1],&amp;c)&#125; Hello, playground 1st a[1] is: 3 addr of map:0x40c130 1st c[1] is: 3 addr of map:0x40c138 1st c[1] is: 4 addr of map:0x40c138 1st a[1] is: 3 addr of map:0x40c130 小结：以c++为准 参数列表，初始化之后不可更改，名称：值 指针为独立的参数，其参数列表中值为本身的地址，初始化之后不可变更 引用作为别名，其参数列表值为引用变量的地址，初始化之后不可变更 指针指向的地址可以可变，引用引用的地址不可改变（参数列表的初始化) 对指针的操作及运算为指针本身的运算eg:++指针指向的地址++ 对引用的运算为引用所引用的对象本身的运算 const int *p， p指向的变量为常量，p可以指向不同的常量 int const * p, p不可改变其指向，其指向的对象为变量 与语言内存模型相关 一般分为堆、栈，堆为数据区（malloc calloc 数组 map chan 对象包括对象成员参数），栈为运行时变量区（局部变量）]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcp-ip-http]]></title>
    <url>%2F2019%2F06%2F29%2Ftcp-ip-http%2F</url>
    <content type="text"><![CDATA[1 socket2 tcp/ip tcp/ip协议详解一篇文章带你熟悉 TCP/IP 协议一篇文章带你熟悉http协议 3 udp4 http协议 http1.0 http1.1 http2.0 http1 建立连接 客户端请求 服务端发送响应并关闭连接 获取响应 http1.1 复用连接,建立连接: 请求1-&gt;响应1, 请求2-&gt;响应2, 其他顺序请求获取响应后才可再次发送请求； 由于复用连接，客户端需要区分每个响应：context-length或者分块传输(Chunked)服务端需提供context-length标明响应body的长度，客户端做区分(服务端必须处理完所有数据才可以发送响应)；http1.1 规定可以不使用Content-Length字段，而使用”分块传输编码”（Chunked Transfer Encoding）。只要请求或响应的头信息有Transfer-Encoding: chunked字段，就表明body将可能由数量未定的多个数据块组成。每个数据块之前会有一行包含一个16进制数值，表示这个块的长度；最后一个大小为0的块，就表示本次响应的数据发送完了。 http2 数据压缩 头跟数据分成不同帧 建立连接 发送请求1 2 3 4 获取请求2 3 1 4 请求返回可以无序 http头堵塞问题：服务端顺序处理请求，若某一请求处理时间较久，其后所有请求排队堵塞 http基于tcp传输层协议，存在tcp头堵塞问题，Tcp全双工 发送不堵塞接收 http2.0采用二进制数据分帧更好的利用底层tcp，解决1.1的队首问题； http2.0利用分帧机制，不再依赖多个TCP连接去实现多流并行了 http2.0客户端发起的流标识为奇数，服务端发起的流标识为偶数 http2.0可以支持优先级，首部压缩减少传输数量量，客户端服务端均可以乱序发送数据，之后通过流标识及帧进行数据重组；http2.0服务端支持数据推送 http2多路复用Tcp全双工：发送数据流头堵塞 按序到达发送堵塞不影响接收http:请求1 请求以数据帧形式发送2 并发发送3 若发送的数据帧出现tcp头堵塞则堵塞返回无需按接收到的请求顺序返回结果完成的结果，按tcp协议写入到socket发送头堵塞不影响接收端接收数据server端处理请求方式：单进程单线程 排队 对头堵塞单进程多线程多进程单线程多进程多线程 消息： 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）； 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等每帧由消息流号标识 http响应四种模型: 单进程I/O模型:服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理； 多进程I/O模型: 服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求； 复用I/O模型: 服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行； 复用多线程I/O模型: 服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。http协议http断开连接http2详解http1.1 vs http2.0http2.0定义的帧http协议详解 TLS(transport layer security) SSL(socket security layer) http明文传输不安全 TSL/SSL介于应用层http及传输层tcp之间的安全层，提供传输数据加密 TSL/SSL客户端与服务端的传输消息为对称加密，对称加密的加密密钥为非对称加密 版本1: server存在公钥&amp;私钥，cli端建立连接后https请求获取公钥，cli端产生随机密码通过公钥对随机密码加密并传输至server端，server通私钥解密获取密码；cli-server对传输消息通过密码加密处理传输 版本1存在问题：窃听者截取cli获取公钥信息将窃听者自己的公钥发送给cli，cli通过窃听者公钥加密后密码传输，窃听者获取密码后，并将密码通过server公钥加密给server； 版本2:CA证书，CA 是 PKI 系统中通信双方信任的实体，被称为可信第三方（Trusted Third Party，简称TTP），CA 证书，就是 CA 颁发的证书 Agree on the version of the protocol to use. Select cryptographic algorithms. Authenticate each other by exchanging and validating digital certificates. Use asymmetric encryption techniques to generate a shared secret key, which avoids the key distribution problem. SSL or TLS then uses the shared key for the symmetric encryption of messages, which is faster than asymmetric encryption.![SSL handshake](../pic/tcp-ip/SSL handshake.gif) step1: client发送”client hello” 消息为加密信息（SSL/TSL版本、客户端带优先级支持的加密套件、随机byte string)列表 step2: server发送”server hello”消息包括密码套件（从cli发送的密码套件组选择的、sessionID、新的随机byte string、数字证书），server端可以请求客户端数字证书 step3: cli认证数字证书 step4: cli发送随机byte string（被证书中公钥加密）至server，用于后续计算出传输消息所用的密码 step5: 若server要求客户端的数字证书，cli将随机数及cli的数字证书（若没有则”no digital certificate alert“代替）公钥加密后发送给server step6: server认证cli数字证书 step7: cli发送”finished”消息，密钥加密 step8: server发送”finished”消息，密钥加密 step9: session内cli和server通过密码进行对称加密消息传输 https TSL/SSL 协议https协议ssl/tsl handshake 4.1 session&amp;&amp;cookie&amp;&amp;tokenhttp协议为无状态协议，如果需要关联不同的http request需要在请求中存储用户数据，可以通过session cookie URL参数 URL参数不安全通过URL地址即可知悉参数；用户信息放置在URL parameter不安全 cookie&amp;URL参数存储在cli端 cookie: 保存在本地终端的数据，服务器产生cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”&quot;)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。下面是一个简单的js使用cookie的例子:用户登录时产生cookie: 12345678910document.cookie = "id="+result.data['id']+"; path=/";document.cookie = "name="+result.data['name']+"; path=/";document.cookie = "avatar="+result.data['avatar']+"; path=/";使用到cookie时做如下解析：var cookie = document.cookie;var cookieArr = cookie.split(";");var user_info = &#123;&#125;;for(var i = 0; i &lt; cookieArr.length; i++) &#123; user_info[cookieArr[i].split("=")[0]] = cookieArr[i].split("=")[1];&#125;$('#user_name').text(user_info[' name']);$('#user_avatar').attr("src", user_info[' avatar']);$('#user_id').val(user_info[' id']); session为会话管理，cli与服务端交互服务端用session保存用户的信息，用户离开即销毁：当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 若server可以产生sessionID(关联用户数据)，cli请求时带sessionID即可;可以对session加过期时间（安全起见）;session用户离开页面过期(一段时间无请求则过期)，用户离开session销毁; cookie 和session的区别, cookie可以只保存sessionID session无法跨机器问题：session外部保存，eg redis缓存1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议：将登陆信息等重要信息存放为SESSION、其他信息如果需要保留，可以放在COOKIE中 token: token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库 JWT标准Token: 实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header（头部）:加密算法，加密设置alg为对应算法，否则alg为none 12345&#123; "alg": "HS256"&#125;意思是这个 JWT 用的算法是 HS256。上面的内容得用 base64url 的形式编码一下，所以就变成这样：eyJhbGciOiJIUzI1NiJ9 payload（数据）：具体内容为标准字段 12345678910111213141516iss：Issuer，发行者sub：Subject，主题aud：Audience，观众exp：Expiration time，过期时间nbf：Not beforeiat：Issued at，发行时间jti：JWT IDeg:&#123; "iss": "ninghao.net", "exp": "1438955445", "name": "wanghao", "admin": true&#125;使用 base64url 编码：eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ signature（签名）: JWT 的最后一部分，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。 123456const encodedString = base64UrlEncode(header) + "." + base64UrlEncode(payload); HMACSHA256(encodedString, 'secret');处理后的签名：SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc最终token为：eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc Token的签发：密钥 加密算法 payload 生成签名，组成token base64URL(head).base64URL(payload).signature;加密算法可选非对称加密 Token的验证：cli cookie传递的token，根据head payload 加密算法 解密密码 验证签名 详细参考: JWT详解 Token ，如果指的是OAuth Token 或类似的机制的话，提供的是认证和授权，认证是针对用户，授权是针对App;其目的是让 某App有权利访问某用户的信息。这里的 Token是唯一的。不可以转移到其它 App上，也不可以转到其它 用户上 token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。 cookie kv形式储存在cli端，可以存储sessionID token等 session服务端生成服务端存储用户相关信息，根据cli传递的session进行信息验证 token由header payload signature组成，表示加密算法 具体信息 签名，服务端保存签名用密码，根据算法 密码对signature进行验证，header payload不可篡改，否则signature验证无法通过； auth2.0认证auth2.0认证 session cookie tokenJWT Json WEB tokentoken原理及应用 4.2 跨域请求(CORS)定义：当前发起请求的域与该请求指向的资源所在的域不一样。域指：协议 + 域名 + 端口号； ​ eg：域名为aaa.cn的网站，它发起一个资源路径为aaa.cn/books/getBookInfo的 Ajax 请求，那么这个请求是同域的，因为资源路径的协议、域名以及端口号与当前域一致（例子中协议名默认为http，端口号默认为80）。但是，如果发起一个资源路径为bbb.com/pay/purchase的 Ajax 请求，那么这个请求就是跨域请求，因为域不一致，与此同时由于安全问题，这种请求会受到同源策略限制。 服务端设置跨域请求相关设置：go-gin可以参考https://github.com/gin-contrib/cors跨域资源请求详解参考网站 4.3 CSRF攻击 浏览器缓存用户登陆过的所有cookie session信息 服务端无法判定是否为用户浏览器发送的请求还是用户发起的请求 攻击者利用用户缓存在浏览器的相关验证信息伪冒用户身份访问相关网站，篡改相关信息 防御方法： (1).Cookie Hashing(所有表单都包含同一个伪随机值)：攻击者无法获取cookie则提交表单时无法包含此伪随机数；服务端进行hash随机数验证，验证通过做相应操作 (2).验证码：用户提交需要填写随机字串 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值) CSRF攻击参考网站 5 webSocket协议5.1 简介WebSocket是一种协议，与HTTP协议一样位于应用层，都是TCP/IP协议的子集。HTTP协议是单向通信协议，只有客户端发起HTTP请求，服务端才会返回数据。而WebSocket协议是双向通信协议，在建立连接之后，客户端和服务器都可以主动向对方发送或接受数据。WebSocket协议建立的前提需要借助HTTP协议，建立连接之后，持久连接的双向通信就与HTTP协议无关了。 WebSocket是应用层协议，是TCP/IP协议的子集，通过HTTP/1.1协议的101状态码进行握手。也就是说，WebSocket协议的建立需要先借助HTTP协议，在服务器返回101状态码之后，就可以进行websocket全双工双向通信了，就没有HTTP协议什么事情了。 WebSocket协议的目标是在一个独立的持久连接上提供全双工双向通信。客户端和服务器可以向对方主动发送和接受数据。在JS中创建WebSocket后，会有一个HTTP请求发向浏览器以发起请求。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。 由于WebScoket使用了自定义协议，所以URL与HTTP协议略有不同。未加密的连接为ws://，而不是http://。加密的连接为wss://，而不是https://。 5.2 对比http 前端通过浏览器与服务端建立tcp长连接，全双工通信 通过http get建立连接 之后升级协议为webSocket http协议请求型，惰性，客服端发起请求，服务端才回复请求 ajax可以通过轮询实现后端推送消息给前端：一定时间后发起http请求，并得到response(不论是否有新的数据),导致后端服务器过忙，很多无用请求;1个request对应一个response,轮询发起http请求 前端通过long poll实现服务端推送消息至前端：前端发起请求，服务端无数据时不发送response直到有新的数据发起response;1个request对应一个response，阻塞在服务端response http流实现后端推送消息至前端：前端发起请求，服务端可以推送多次response;一个request对应多个response ajax轮询 需要服务器有很快的处理速度和资源。（速度） long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小） 传统轮询技术(Ajax短轮询)是客户端向服务器发起HTTP请求，无论数据是否更新，服务器都会传输数据。一个request对应一个response。服务器推送技术(Ajax长轮询)是短轮询的变种，是客户端向服务器发起HTTP请求，只有等待数据更新后才会传输数据，否则服务器保持连接状态。接着发起下一次HTTP请求，一个request对应一个response。服务器推送技术(HTTP流)，在客户端只发起一次HTTP请求，服务器保持连接状态，在数据更新之后，服务器会传输数据，否则保持连接状态。此时一个requset对应多个response。无论是短轮询、长轮询，还是HTTP流，相同点在于都需要客户端先发起HTTP请求。 5.3 示例Js webSocketAPI 打开WebSocket, 传递的参数url没有同源策略的限制。1234567891011121314151617181920212223242526let websocket = new WebSocket(url)// 监听open事件，在成功建立websocket时向url发送纯文本字符串数据(如果是对象则必须序列化处理)。websocket.onopen = () =&gt; &#123; if (websocket.readyState === WebSocket.OPEN) &#123; websocket.send(&apos;hello world&apos;) &#125;&#125;// 监听message事件，在服务器响应时接受数据。返回的数据存储在事件对象中。websocket.onmessage = e =&gt; &#123; let data = e.data console.log(data)&#125;// 监听error事件，在发生错误时触发，连接不能持续。websocket.onerror = () =&gt; &#123; console.log(&apos;websocket connecting error!!&apos;)&#125;// 监听close事件，在连接关闭时触发。只有close事件的事件对象拥有额外的信息。可以通过这些信息来查看关闭状态websocket.onclose = e =&gt; &#123; let clean = e.wasClean // 是否已经关闭 let code = e.code // 服务器返回的数值状态码。 let reason = e.reason //服务器返回的消息。&#125; 看完让你彻底搞懂Websocket原理webSocket协议webSocket协议解析golang中的webSocket实现golang官方webSocket实现 6 并发编程 select I/O复用7 前后端通信 前端作为通信的cli端，若http协议只能通过请求获取response 服务端之间通信: 服务端均可作为通信的server端存在 服务端A B B推送消息给A，A作为server端，B作为cli端调用接口(http rpc)发送消息给A； B主动发起请求，获取response A需要从B获取消息: B作为server端提供响应接口，A作为cli端调用B(http rpc)； A主动发起请求获取response 8 其他 IP地址是逻辑地址用来标识网络中的一个主机，ip地址唯一，计算机间通信通过ip IP分公有ip及私有ip，公有ip全球可以访问，私有地址(以192.168.开头)不能直接在internet网络中应用 IP地址=网络地址+主机地址 网络地址就是判断网络中的计算机在不在同一网络,在就能通,不在就不能通 网络地址: IP地址&amp;子网掩码，二进制计算获取网络地址 域名internet中计算机或者计算机组的名称,域名便于人类记忆 DNS(Domain name server): 域名服务器，存有域名跟ip的对应表，可以将域名解析为ip； chrom浏览器输入google.com：1 请求dns服务器解析google.com获取ip地址 2 与该ip建立连接 用网线直接连接的计算机或是通过HUB（集线器）或普通交换机间接的计算机之间要能够相互通,计算机必须要在同一网络；即网络地址必须相同 网络A的IP地址范围为“192.168.1.1192. 168.1.254”，网络B的IP地址范围为“192.168.2.1192.168.2.254”，两者的子网掩码为255.255.255.0 网络A与B在不同的网络中不能直接通信，两者必须通过网关通信：如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机 网关的IP地址是具有路由功能的设备的IP地址： 路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。 一台主机可以有多个网关,主机找不到可用网关则使用默认网关 自动设置就是利用DHCP（Dynamic Host Configuration Protocol, 动态主机配置协议）服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关 。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。另外一种自动获得网关的办法是通过安装代理服务器软件（如MS Proxy）的客户端程序来自动获得，其原理和方法和DHCP有相似之处。 IP地址，子网掩码，默认网关，DNS服务器详解]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
        <tag>http1.0-2</tag>
        <tag>webSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go基础整理]]></title>
    <url>%2F2019%2F06%2F20%2Fgo-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1 go方法 方法分为方法类型及方法值 方法类型：方法接收器的类型+方法名 方法值：方法接收器+方法名 方法类型及方法值均可以直接作为函数调用，方法类型函数调用时第一个参数为接收器类型，类型不会自动转换 方法值直接定义了接收器，接收器类型可自动转换，方法接收器的类型的实质不可以为指针或者interface；字面量取不到对应地址 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt")type test struct&#123;a intb int&#125;func main() &#123; fmt.Println("Hello, playground") b := test&#123;2,2&#125; b.show("直接调用") // 1 方法表达式 c := test.show // 方法表达式 c(b,"方法表达式调用") // 调用方法表达式需要指定接收器 // 2 方法的值 d := b.show // 或者(&amp;b).show 方法值调用自动指定接收器，类型可自动转换 d("方法值调用方式") // 方法指针 e := (*test).show1 // 方法表达式 为指针 e(&amp;b, "方法表达式调用") // 接收器为指针，不会自动转换 f := (&amp;b).show1 // 或者b.show1 f("方法值调用") &#125;func (a test) show(b string)&#123;fmt.Printf("%s: %+v\n",b, a)&#125;// 不可重名func (a *test) show1(b string)&#123;a.a=1fmt.Printf("%s: pointer %+v\n",b, *a)&#125; 2 go接口 接口定义了规约 接口定义方法签名，interface{}类型为interface{}类型只是任意类型均实现了该接口，会隐士转换类型 接口值包括type&amp;&amp;value 接口为nil为接口值的type&amp;&amp;value均为nil 接口值的type类型必须实现接口对应的方法；go语言为静态语言，编译时无法知道接口的动态类型，？？？？接口的编译 接口初始化时会判定相应的初始化时是否实现了接口类型 接口的实现为指针时，接口初始化值不可以为变量必须为指针(go传参数为值copy类型) 接口的实现为值时，接口初始化可以为指针也可以为变量，指针可以隐士解引获取对应的底层变量 接口详细介绍及底层实现 接口隐士实现：实现即接口 看代码：flag及sort的实现 示例： 1234567891011121314151617181920212223242526272829package mainimport ( "fmt")type testInterface interface&#123;set(a string)show()&#125;type testHello struct&#123;info string&#125;func (a *testHello) set(b string)&#123;a.info=b&#125;func (a *testHello) show()&#123;fmt.Println("here is: ", a.info)&#125;func main() &#123; var hello testHello hello.info="123" var testType testInterface = &amp;hello //接口类型为testInterface,接口值为动态变量的类型及值，接口的值分为type&amp;&amp;value //接口值： 1 type=*testHello 2 value=&amp;hello；接口值中type必须实现接口定义的方法 // testInterface=hello错误 //cannot use hello (type testHello) as type testInterface in assignment: //testHello does not implement testInterface (set method has pointer receiver) testType.set("hello world") testType.show() fmt.Printf("%T",hello)&#125; 123456789101112131415161718192021package mainimport ( "fmt")type testInterface interface&#123;show()&#125;type testHello struct&#123;info string&#125;func (a testHello) show()&#123;fmt.Println("here is: ", a.info)&#125;func main() &#123; var hello testHello hello.info="123" var testType testInterface = &amp;hello //接收类型为非指针类型，interface值的type可以为指针也可以为非指针 testType.show() fmt.Printf("%T",hello)&#125; 2.1 反射12345678910111213141516171819202122232425262728293031323334353637383940414243444546// resRaw为json byte,&#123;"code": , "data": , "message": &#125;// 将[]byte解析为type res struct&#123;Code int, Message string, Data interface&#123;&#125;&#125;, json tag分别为code message data// 兼容data为空及存在值时返回类型不同，data单独解析，首先判空// resType struct&#123;Code int, Message string, Data []byte&#125;func parser(resRaw []byte, res interface&#123;&#125;) error &#123; if resRaw == nil &#123; return errors.New("empty raw byte") &#125; var resOri resType if err := json.Unmarshal(resRaw, &amp;resOri); err != nil &#123; return err &#125; // 获取res的类型及值，解析通常传指针 map []slice t := reflect.TypeOf(res) v := reflect.ValueOf(res) // 指针处理 获取实际类型的type及值 if t.Kind() == reflect.Ptr &#123; t = t.Elem() v = v.Elem() &#125; // 结构体 if t.Kind() != reflect.Struct &#123; log.Println("Check type error not Struct") return nil &#125; members := t.NumField() // 处理方式1 fieldByName //v.FieldByName("Code").Set(reflect.ValueOf(resOri.Code)) //v.FieldByName("Message").Set(reflect.ValueOf(resOri.Message)) // 按照json Tag解析字串 for i := 0; i &lt; members; i++ &#123; // 获取field tag json tag switch t.Field(i).Tag.Get("json") &#123; case "data": if err := parseBody(resOri.Data, v.Field(i).Interface()); err != nil &#123; return err &#125; case "code": v.Field(i).Set(reflect.ValueOf(resOri.Code)) case "message": v.Field(i).Set(reflect.ValueOf(resOri.Message)) &#125; &#125; return err&#125; 3 Go工具3.1 go test3.2 go mock (单测数据模拟)Linksref-1github gomock]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot整理]]></title>
    <url>%2F2019%2F06%2F17%2Fspring-boot%2F</url>
    <content type="text"><![CDATA[SpringBoot Issues springboot正常启动访问404 ：Springboot会自动扫描启动类同级包及其同级包的子包所有的注解。如果想自己控制扫描哪些包的话，使用@componentscan注解，多个包的话使用逗号分隔如：@componentscan(“com.package1,cn.package2”) 用法 配置文件，参数配置,参数引用 变量配置:resource中配置两个文件application.properties &amp;&amp; application-dev.properties; 分配配置端口server.port为8081 &amp;&amp; 8088 java运行命令： java -Dspring.profiles.active=dev -jar target/XXXX.jar 或者 java -jar XX.jar –spring.profiles.active=dev 实际运行端口为application-dev.properties文件中的配置 参数引用：通过@Value将私有变量value1定义为配置文件中com.test.rand对应值 com.example.web;123456789101112import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.RequestMapping; @RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;com.test.rand&#125;&quot;) private String value1; @RequestMapping(&quot;/hello&quot;) public String index()&#123; return value1; &#125;&#125; spring DI spring可以注入class注册到bean spring bean可以由xml文件定义bean 应用程序支持spring注解需要配置app-context-annotation.xml文件,告诉spring扫描代码，找到@Component @Controller @Respository @Service注解的注入bean以及支持在指定包（及所有子包）下使用@Autowired @Inject @Resource注解的beanxml文件配置可以被java配置替代(如下代码中的@Configuration) 123// app-context-annotation.xml文件:&lt;context:componet-scan base-package="com.apress.prospring5.ch3.annotation"/&gt; app-context-xml.xml文件: 12345 &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; java配置 1234567891011121314151617181920212223// 注解配置，ctx直接调用该配置，通过bean可以自动实现interface// 该配置可以获取provider及renderer interface// java配置可以同过xml文件注入eg: @ImportResource(locations = &#123;"classpath:spring/app-context-xml.xml"&#125;)@ComponentScan(basePackages = &#123;"com.apress.prospring5.ch3.annotation) //必须启动组建扫描@Configurationpublic class HelloWorldConfiguration&#123; @Bean public MessageProvider provider() &#123; return new HelloWorldMessageProvoder(); // provider具体实现class &#125; @Bean public MessageRenderer renderer()&#123; // renderer的具体实现class MessageRenderer renderer = new StandardOutMessageRenderer(); renderer.setMessageProvider(provider()); return renderer; &#125;&#125;// 以上配置替代app-context-xml.xml文件: &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; setter注入中指定标记（每个标记注入一个依赖项）代码片段如下: 123456&lt;bean id="renderer" class=.....StandardOutMessageRenderer"&gt; &lt;property name="messageProvider" ref="provider"/&gt;&lt;/bean&gt;&lt;bean id="provider"class=....HelloWorldMessageProvider/&gt; spring2.5以上： 12345 &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; setter注入注解方式： 12345678@Service("renderer")public class StandardOutMessageRenderer implements MessageRenderer&#123; @Overrider @Autowired //可使用@Resource(name="messageProvider") public void setMessageProvider(MessageProvoder provoder)&#123; this.messageProvider = provider; &#125;&#125; 构造函数注入 12345678910public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; public ConfigurableMessageProvider(String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 创建ConfigurableMessageProvider需要提供非null的消息值，重定义xml创建实例，使用构造函数注入消息: 1234 &lt;bean id="messageProvider"class=....ConfigurableMessageProvider/&gt;&lt;constructonr-arg type="String" value="I hope..."/&gt;&lt;/bean&gt; 多个构造函数使用indexSpring3.1起参数可以用c名称空间，即 123&lt;constructonr-arg value="I hope..."/&gt;&lt;/bean&gt;修改为：c:message="I I hope..." 构造函数使用注解： 123456789101112public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; // @Value能注入值 @AutoWired public ConfigurableMessageProvider(@Value("configurable message") String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 1234567891011121314151617181920将@Value变为外部文件注入xml文件变为：&lt;context:componet-scan base-package="com.apress.prospring5.ch3.annotation"/&gt; &lt;bean id="message" class="java.lang.String" c:_0="I hope ..."/&gt;其中c:_0中_0为索引对应代码为：构造函数中value会由bean自动注入public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; // @Value能注入值 @AutoWired public ConfigurableMessageProvider(String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 通过注解指定用于构造的构造方法: 12345678910111213141516171819202122@Servicepublic class ConstructorConfusion()&#123;private String somevaluepublic void ConstructorConfusion(String somevalue)&#123; System.out.println("ConstructorConfusion(string) called"); this.somevalue=somevalue;&#125;@Autowired //指定了构造函数，只能用于一个public void ConstructorConfusion(int somevalue)&#123; System.out.println("ConstructorConfusion(int) called"); this.somevalue="Number: "+Integer.toString(somevalue);&#125;public String toString()&#123; return somevalue;&#125;public static void main(String... args)&#123;GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-annotation.xml");ctx.refresh();ConstructorConfusion cc=(ConstructorConfusion)ctx.getBean("constructorConfusion");System.out.println(cc);ctx.close(); 字段注入:依赖直接注入字段，不需要构造函数及setter,通过@Autowired 不能用于final字段，只能通过构造函数 注入参数 setter与构造函数分别通过及标记注入示例如下： 12345678910111213141516171819202122232425262728293031public class InjectSimple &#123;prviate String name;private int age;private float height;public static void main(String... args)&#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-xml.xml");ctx.refresh();InjectSimple simple = (InjectSimple)ctx.getBean("injectSimple");System.out.println(simple);ctx.close();&#125;public void setAge(String age)&#123; this.age=age;&#125;public void setName(String name)&#123; this.name=name;&#125;public void setHeight(float height)&#123; this.height=height;&#125;app-context-xml.xml&lt;beans ...&gt; &lt;bean id="injectSimpleConfig" class="com.apress.prospring5.ch3.xml.InjectSimpleConfig"/&gt; &lt;bean id="injectSimpleSpel" class="com.apress.prospring5.ch3.xml.InjectSimpleSpel" p:name="xx" p:age="123" p:height="1.1"/&gt;&lt;/beans&gt; 注解方式: 12345678910111213141516171819202122232425@Service("injectSimple") //或者spel注入@Service("injectSimpleSpel")public class InjectSimple &#123;@Value("xx") //或者spel注入 @Value("#&#123;injectSimpleConfig.name&#125;")prviate String name;@Value("11") //或者spel注入 @Value("#&#123;injectSimpleConfig.age +1 &#125;")private int age;@Value("1.1")private float height;public static void main(String... args)&#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-xml.xml");ctx.refresh();InjectSimple simple = (InjectSimple)ctx.getBean("injectSimple");System.out.println(simple);ctx.close();&#125;public void setAge(String age)&#123; this.age=age;&#125;public void setName(String name)&#123; this.name=name;&#125;public void setHeight(float height)&#123; this.height=height;&#125; 123456789101112131415161718192021//调用方式：// 1 xml文件配置publci class DeclareSpringComponents &#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // A、加载app-context-annotation.xml文件 告知spring扫描代码找到注解, interface的具体实现class必须带注解;使用annotation包中注解定义的bean // B、 加载app-context-xml.xml ctx.load("classpath:spring/app-context-xml.xml);//可以将app-context-xml.xml 替换为app-context-annotation.xml，只要class的实现添加了注解，则两者实现完全一致 ctx.refresh(); MessageRenderer messageRenderer = ctx.getBean("renderer", MessageRenderer.class); messageRenderer.render(); ctx.close();&#125;// 2 配置类public class HelloWorldAnnotated &#123; public static void main(String... args) &#123; // 加载配置类 ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfiguration.class); MessageRenderer messageRenderer = ctx.getBean("renderer", MessageRenderer.class); messageRenderer.render(); spring框架主要：interface + DI (dependency injection) 通过applicationContext获取interface的具体实现class，通过ctx.getbean自动实现interface，spring 框架自动处理 setter注入，java 配置， 构造函数实现 java配置 10 参考查询spring注解]]></content>
      <tags>
        <tag>java, spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础整理]]></title>
    <url>%2F2019%2F06%2F14%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java基础 序列化 将对象的状态信息转化为可以存储或者传输的形式的过程 储存媒介档案、记忆缓冲体；网络传输中为：字节或者xml文件 反序列化存储形式还原为对象 创建的对象在jvm的stack中，jvm停止对象消失，序列化持久对象需要的时候反序列化恢复 应用场景: RMI(远程方法调用)及网络传输 API接口：java.io.Serializable &amp;&amp; java.io.Externalizable 序列化时，并不保存静态变量: 序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量 Transient关键字: 控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值 Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。若不定义这两个方法的实现细节，则输出的内容为空。 在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。 java编译&amp;&amp;运行 javac将java程序编译成二进制字节码class jvm虚拟机：加载class 编译成机器码(JIT编译时运行动态编译，AOT先编译后运行) 内存管理 java为跨平台语言，运行在jvm虚拟机上，虚拟机本身处理不同操作系统平台问题 JIT编译&amp;&amp;运行节省空间效率低，编译跟运行共分资源影响运行； AOT编译完运行，占用空间，运行效率高 JIT VS AOTjava虚拟机java基础 jvm vs vmWare jvm是虚拟进程：程序计数 内存管理 虚拟cpu 启动不同的java程序会启动不同的jvm进程 java程序依赖与jvm进程 vmWare为虚拟机器: 进程管理 i/o cpu 网络i/o [vmWare vs docker] (https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-virtual-machine) docker应用打包：资源隔离 应用打包 应用依赖 应用的环境变量等 docker虚拟操作系统共享内核 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。 docker Docker 是世界领先的软件容器平台。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于 LXC. Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。 用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 java注解&amp;&amp;反射 注解类似标签不是程序，通过反射可以获取注解，obj.getclass 利用class获取类中成员 方法 类本身等的注解 注解可以定义期时间周期 反射获取类信息 方法等，方法可以通过invoke执行对应的方法 invoke示例 代码类似如下： 主入口： tags.*;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;@SuppressWarnings(&quot;deprecation&quot;)@TestAnnotation()public class MyAnnotation &#123; @Check int a; @Perform public void testMethod()&#123;&#125;; @SuppressWarnings(&quot;deprecation&quot;) public void test1()&#123; Hero myHero = new Hero(); myHero.speak(); myHero.speak(); int b = a; System.out.println(b); &#125; private int test2(int c, int d)&#123; return c+d; &#125; public MyAnnotation(int ...b )&#123; a=b[0]; &#125; public static void main(String[] args)&#123; boolean ifAnnotation = MyAnnotation.class.isAnnotationPresent(TestAnnotation.class); if (ifAnnotation)&#123; TestAnnotation testAnnotation = MyAnnotation.class.getAnnotation(TestAnnotation.class); System.out.println(&quot;the id of annotation is: &quot;+testAnnotation.id()); System.out.println(&quot;the string of annnotaion is: &quot; + testAnnotation.msg()); &#125; MyAnnotation myTest = new MyAnnotation(1,2); Class myClass = myTest.getClass(); Field[] myFields = myClass.getDeclaredFields(); for (Field myField : myFields)&#123; System.out.println(myField); &#125; Method[] methods = myClass.getDeclaredMethods(); // 示例method.invoke // methodXX.invoke(Object obj, Object ...args)利用指定的参数args执行指定对象obj中该方法，返回值为object型 for (Method method : methods)&#123; if (method.getName()==&quot;test2&quot;) &#123; try &#123;System.out.println(&quot;res of invoke: &quot;+ method.invoke(myTest, new Object[] &#123;new Integer(10), new Integer(20)&#125;)); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; try &#123; Field a = MyAnnotation.class.getDeclaredField(&quot;a&quot;); a.setAccessible(true); Check check = a.getAnnotation(Check.class); if (check != null) &#123; System.out.println(check.value()); &#125; Constructor[] test = MyAnnotation.class.getConstructors(); int modifiers = test[0].getModifiers(); System.out.println(Modifier.isPrivate(modifiers)); for (Constructor tets : test)&#123; System.out.println(&quot;构造函数是否带参数: &quot;+ tets.isVarArgs()); &#125; &#125;catch (NoSuchFieldException e)&#123; e.printStackTrace(); &#125;catch (SecurityException e)&#123; e.printStackTrace(); &#125; &#125;&#125; package tags 12345678910111213141516171819202122232425262728293031323334353637383940package tags;public @interface Check &#123; //注解的属性 名为value类型为string默认值为"hi" String value() default "hi";&#125;package tags;public class Hero &#123; @Deprecated() public void say()&#123; System.out.println("Noting has to say!"); &#125; public void speak()&#123; System.out.println("I have a dream!"); &#125;&#125;package tags;public @interface Perform &#123;&#125;package tags;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//target为基本注解限定注解可以使用的范围@Target(ElementType.TYPE)// retention限定注解的生命周期@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id() default 1; String msg() default "hi";&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 内存]]></title>
    <url>%2F2019%2F06%2F14%2Fgo_mem%2F</url>
    <content type="text"><![CDATA[go内存模型 内存模型剖析 待补充 逃逸分析 编译参数加入 -gcflags ‘-m -l’ go消除堆栈区别 逃逸分析确定变量的储存区域为堆/栈，减少gc压力，栈可以直接回收，栈分配空间及回收空间较快 代码段 main12345678910111213141516171819202122import ( &quot;time&quot; &quot;fmt&quot;)func main()&#123; //go_parser.TestParser(&quot;a==1 &amp;&amp; b!=2&quot;) res := make(map[string]int) fmt.Println(res[&quot;res&quot;]) fmt.Println(int(time.Now().Weekday())) // test grpc dispatch get scenes //grpc.GetScene(20351, imkfdispatch.Scene_BuyCarConsult) res1 := taoyi() fmt.Println(&quot;2st addr of i: &quot;, res1) i := *res1 fmt.Println(&quot;the res is: %d&quot;, i) fmt.Println(&quot;3st addr of i: &quot;, &amp;i)&#125;func taoyi()(*int)&#123; var i int = 1 fmt.Println(&quot;1st addr of i: &quot;, &amp;i) return &amp;i&#125; 输出内容： ./main.go:25:14: “1st addr of i: “ escapes to heap./main.go:25:33: &amp;i escapes to heap./main.go:25:33: &amp;i escapes to heap./main.go:24:6: moved to heap: i./main.go:26:9: &amp;i escapes to heap./main.go:25:13: taoyi … argument does not escape./main.go:11:17: res[“res”] escapes to heap./main.go:13:17: int(time.Now().Weekday()) escapes to heap./main.go:17:14: “2st addr of i: “ escapes to heap./main.go:17:14: res1 escapes to heap./main.go:19:14: “the res is: %d” escapes to heap./main.go:19:14: i escapes to heap./main.go:20:14: “3st addr of i: “ escapes to heap./main.go:20:33: &amp;i escapes to heap./main.go:20:33: &amp;i escapes to heap./main.go:18:2: moved to heap: i./main.go:10:13: main make(map[string]int) does not escape./main.go:11:13: main … argument does not escape./main.go:13:13: main … argument does not escape./main.go:17:13: main … argument does not escape./main.go:19:13: main … argument does not escape./main.go:20:13: main … argument does not escape 参考1]]></content>
      <tags>
        <tag>go,内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常处理]]></title>
    <url>%2F2019%2F06%2F12%2Fjava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1 自定义异常]]></content>
      <tags>
        <tag>java, 异常</tag>
      </tags>
  </entry>
</search>
