<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[os]]></title>
    <url>%2F2019%2F07%2F02%2Fos%2F</url>
    <content type="text"><![CDATA[1 unix基础及标准1.1 体系结构 内核：控制计算机硬件资源，提供程序运行环境 系统调用：内核接口 应用程序：直接调用内核||通过库函数调用内核||通过shell程序 shell：特殊应用程序为其他应用程序提供接口；命令行解释器：读取用户输入然后执行命令； ![操作系统体系结构](../pic/os/unix操作系统体系结构.png) 1.2 login 口令文件: /etc/passwd文件 文件内容为7个以冒号分割的字段即：”登陆名:加密口令:数字用户ID:数字组ID:注释字段:起始目录:shell程序”, eg: “sar:x:205:105:Stephen Rago:/home/sar/:/bin/ksh” 用户登陆后：a 系统显示系统消息； b 某些系统启动视窗管理程序，最终shell程序运行在视窗中； c 用户向shell程序键入命令 1.3 文件和目录 unix文件和目录为层次结构起始为:”/“ 目录：包含目录项的文件,包含一个文件名及文件属性； 文件属性：文件类型(普通文件,目录)、文件大小、文件所有者、文件权限、文件最后修改时间等 stat、fstat:返回文件属性信息 创建目录自动创建两个文件名:. .. ls命令：遍历相应目录文件，获取记录输出记录的文件名 工作目录：每个进程均有工作目录，可以通过chdir更改工作目录 起始工作目录：login时从口令文件中获取，参考 1.2 login 每个文件均包括：所有者的用户ID及组ID 1.4 输入&amp;&amp;输出 文件描述符：非负小整数，内核标识一个进程正在访问的文件 stdin stdout stderr 不带缓冲IO(系统调用)：open read write lseek close 标准IO(库函数)：提供带缓冲接口，调用方不用关心buffSize的选取, eg printf 1.5 程序&amp;&amp;进程 程序：磁盘上可执行文件 进程：程序执行实例，进程ID唯一标识 进程存在进程所有者用户ID及组ID 进程控制: fork exec waitpid 线程: 线程ID，一个进程的所有线程共享同一地址空间、文件描述符、栈及与进程相关属性；线程访问共享数据需要做同步处理； 1.6 出错处理 返回负值设置errno 不同的线程有自己局部errno 致命错误：输出错误并退出 非致命错误：妥善处理，资源类错误可延迟重试，eg EAGAIN ENFILE ENOBUFS ENOLCK ENOSPC EWOULDBLOCK等 1.7 用户标识(用于权限控制) 用户ID：login时获取系统管理员登陆时分配(/etc/passwd文件)，唯一，用户不可更改，0位根用户或超级用户 组ID: login时获取，(/etc/group文件) 附属组ID:用户可以配置多个附属组作权限控制，大多系统最多16个(/etc/group文件) 1.8 信号 通知进程发生了某种情况：除0发送SIGFPE信号 信号处理：a 忽略； b 系统默认处理方式; c 捕获信号，提供函数信号发生时调用 产生信号：终端中断键del或ctrl+c，退出键ctrl+\，调用kill函数（向进程发送信号必须是进程所有者或者超级用户) 1.9 时间值 日历时间：协调世界时间(Coordinated Universal Time, UTC)1970/01/01 00:00:00后秒数累计，记录文件最近一次修改时间; 进程时间：时钟滴答，cpu时间，度量进程使用的cpu时间，每秒曾取50、60或者100个时钟滴答 进程时间：时钟时间(墙上时钟时间wall clock time，进程运行的总时间)、用户时间（执行用户指令所用时间）、系统时间 1.10 系统调用和库函数 库函数封装系统调用，提供更复杂功能，系统调用提供一种最小接口； eg sbrk为进程分配空间，地址空间管理由进程处理，内核中系统调用分配一块空间给进程，库函数malloc在用户层次管理进程的内存空间; ![系统调用和库函数](../pic/os/系统调用和库函数.jpeg)]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2019%2F06%2F29%2Fjava%2F</url>
    <content type="text"><![CDATA[java参数传递 vs c++引用 vs go指针传递 c++引用 引用 引用不可为空，对象必须存在不可为null 地址概念：某块内存的别名 引用是别名，地址不可更改 引用使用无需解引*，对引用的赋值为对地址变量的赋值 sizeof引用为引用指向的对象的大小 i 123int j = 6; int &amp;k = i; k = j; // k 和i 的值都变成了6; java引用 引用 值传递 所有的参数传递都是 传值，从来没有 传引用 这个事实； 所有的参数传递都会在 程序运行栈上 新分配一个 值 的复制品； java只有按值传递，所谓的按地址(引用)传递，也属于按值传递，只不过这个“值”是个地址; 对于引用类型的传参也是传值的，传的是引用类型的值，其实就是对象的地址； java所有对像变量都是对像的引用； 函数的形式参数，是传入参数的拷贝；引用变量之间拷贝的是【地址】，基本变量之间拷贝的是 内存中的值 （被称为直接量）； class Test1123456789101112131415&#123; String a = &quot;123&quot;; public static void test(Test1 test) &#123; test.a = &quot;abc&quot;;//更改test指向的内存空间的值 &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(); test1.a = &quot;567&quot;; System.out.println(test1.a); //567 test(test1);//复制test1的地址至test System.out.println(test1.a); //abc &#125;&#125; java引用可以改变引用的地址，java引用.为对引用地址所指向对象的操作，=表示对引用本身的修改（地址) class Test1234567891011121314&#123; public static void test(StringBuffer str) &#123; str.append(&quot;world&quot;);//改变引用对象的内存空间的值 str = new StringBuffer(&quot;world&quot;);//更新地址，并对地址对象赋值，不会改变原值 &#125; public static void main(String[] args) &#123; StringBuffer str = new StringBuffer(&quot;hello&quot;); System.out.println(str); //hello test(str);//复制地址 System.out.println(str); //注释掉str.append为hello，否则为hello world &#125;&#125; 参考1: java参数传递参考2: java堆栈 go(c语言)指针传递 类似C语言，函数传值一切皆copy 参数为指针则为指针所指向的地址的值copy main12345678910111213141516171819202122import ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello, playground&quot;) var a int = 1 b := &amp;a fmt.Println(&quot;the addr of b: &quot;,&amp;b, &quot;, a: &quot;, &amp;a, &quot; value of b: &quot;, b, &quot;the value of *b: &quot;, *b) fun1(b) fmt.Println(&quot;2st the addr of b: &quot;,&amp;b, &quot;, a: &quot;, &amp;a, &quot; value of b: &quot;, b, &quot;the value of *b: &quot;, *b) &#125;func fun1(c *int)&#123;fmt.Println(&quot;the add of c: &quot;, &amp;c, &quot;the value of c: &quot;, c, &quot;the value of *c: &quot;, *c)var d int = 2c = &amp;dfmt.Println(&quot;2 st the add of c: &quot;, &amp;c, &quot;the value of c: &quot;, c, &quot;the value of *c: &quot;, *c)&#125; Hello, playgroundthe addr of b: 0x40c130 , a: 0x414020 value of b: 0x414020 the value of *b: 1 the add of c: 0x40c138 the value of c: 0x414020 the value of *c: 1 2 st the add of c: 0x40c138 the value of c: 0x41402c the value of *c: 2 2st the addr of b: 0x40c130 , a: 0x414020 value of b: 0x414020 the value of *b: 1 传map main123456789101112131415161718192021222324import ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello, playground&quot;) a := make(map[int]int) a[1]=3 fmt.Printf(&quot;1st a[1] is: %d addr of map:%p \n&quot;, a[1],&amp;a) fun1(a) fmt.Printf(&quot;1st a[1] is: %d addr of map:%p \n&quot;, a[1],&amp;a) &#125;func fun1(c map[int]int)&#123;fmt.Printf(&quot;1st c[1] is: %d addr of map:%p \n&quot;, c[1],&amp;c)c=make(map[int]int)c[1]=4fmt.Printf(&quot;1st c[1] is: %d addr of map:%p \n&quot;, c[1],&amp;c)&#125; Hello, playground 1st a[1] is: 3 addr of map:0x40c130 1st c[1] is: 3 addr of map:0x40c138 1st c[1] is: 4 addr of map:0x40c138 1st a[1] is: 3 addr of map:0x40c130 小结：以c++为准 参数列表，初始化之后不可更改，名称：值 指针为独立的参数，其参数列表中值为本身的地址，初始化之后不可变更 引用作为别名，其参数列表值为引用变量的地址，初始化之后不可变更 指针指向的地址可以可变，引用引用的地址不可改变（参数列表的初始化) 对指针的操作及运算为指针本身的运算eg:++指针指向的地址++ 对引用的运算为引用所引用的对象本身的运算 const int *p， p指向的变量为常量，p可以指向不同的常量 int const * p, p不可改变其指向，其指向的对象为变量 与语言内存模型相关 一般分为堆、栈，堆为数据区（malloc calloc 数组 map chan 对象包括对象成员参数），栈为运行时变量区（局部变量）]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcp-ip-http]]></title>
    <url>%2F2019%2F06%2F29%2Ftcp-ip-http%2F</url>
    <content type="text"><![CDATA[1 socket2 tcp/ip 3 udp4 http协议 http1.0 http1.1 http2.0 http1 建立连接 客户端请求 服务端发送响应并关闭连接 获取响应 http1.1 复用连接,建立连接: 请求1-&gt;响应1, 请求2-&gt;响应2, 其他顺序请求获取响应后才可再次发送请求； 由于复用连接，客户端需要区分每个响应：context-length或者分块传输(Chunked)服务端需提供context-length标明响应body的长度，客户端做区分(服务端必须处理完所有数据才可以发送响应)；http1.1 规定可以不使用Content-Length字段，而使用”分块传输编码”（Chunked Transfer Encoding）。只要请求或响应的头信息有Transfer-Encoding: chunked字段，就表明body将可能由数量未定的多个数据块组成。每个数据块之前会有一行包含一个16进制数值，表示这个块的长度；最后一个大小为0的块，就表示本次响应的数据发送完了。 http2 数据压缩 头跟数据分成不同帧 建立连接 发送请求1 2 3 4 获取请求2 3 1 4 请求返回可以无序 http头堵塞问题：服务端顺序处理请求，若某一请求处理时间较久，其后所有请求排队堵塞 http基于tcp传输层协议，存在tcp头堵塞问题，Tcp全双工 发送不堵塞接收 http2.0采用二进制数据分帧更好的利用底层tcp，解决1.1的队首问题； http2.0利用分帧机制，不再依赖多个TCP连接去实现多流并行了 http2.0客户端发起的流标识为奇数，服务端发起的流标识为偶数 http2.0可以支持优先级，首部压缩减少传输数量量，客户端服务端均可以乱序发送数据，之后通过流标识及帧进行数据重组；http2.0服务端支持数据推送 http2多路复用Tcp全双工：发送数据流头堵塞 按序到达发送堵塞不影响接收http:请求1 请求以数据帧形式发送2 并发发送3 若发送的数据帧出现tcp头堵塞则堵塞返回无需按接收到的请求顺序返回结果完成的结果，按tcp协议写入到socket发送头堵塞不影响接收端接收数据server端处理请求方式：单进程单线程 排队 对头堵塞单进程多线程多进程单线程多进程多线程 消息： 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）； 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等每帧由消息流号标识 http响应四种模型: 单进程I/O模型:服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理； 多进程I/O模型: 服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求； 复用I/O模型: 服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行； 复用多线程I/O模型: 服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。http协议http断开连接http2详解http1.1 vs http2.0http2.0定义的帧 5 webSocket协议5.1 简介WebSocket是一种协议，与HTTP协议一样位于应用层，都是TCP/IP协议的子集。HTTP协议是单向通信协议，只有客户端发起HTTP请求，服务端才会返回数据。而WebSocket协议是双向通信协议，在建立连接之后，客户端和服务器都可以主动向对方发送或接受数据。WebSocket协议建立的前提需要借助HTTP协议，建立连接之后，持久连接的双向通信就与HTTP协议无关了。 WebSocket是应用层协议，是TCP/IP协议的子集，通过HTTP/1.1协议的101状态码进行握手。也就是说，WebSocket协议的建立需要先借助HTTP协议，在服务器返回101状态码之后，就可以进行websocket全双工双向通信了，就没有HTTP协议什么事情了。 WebSocket协议的目标是在一个独立的持久连接上提供全双工双向通信。客户端和服务器可以向对方主动发送和接受数据。在JS中创建WebSocket后，会有一个HTTP请求发向浏览器以发起请求。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。 由于WebScoket使用了自定义协议，所以URL与HTTP协议略有不同。未加密的连接为ws://，而不是http://。加密的连接为wss://，而不是https://。 5.2 对比http 前端通过浏览器与服务端建立tcp长连接，全双工通信 通过http get建立连接 之后升级协议为webSocket http协议请求型，惰性，客服端发起请求，服务端才回复请求 ajax可以通过轮询实现后端推送消息给前端：一定时间后发起http请求，并得到response(不论是否有新的数据),导致后端服务器过忙，很多无用请求;1个request对应一个response,轮询发起http请求 前端通过long poll实现服务端推送消息至前端：前端发起请求，服务端无数据时不发送response直到有新的数据发起response;1个request对应一个response，阻塞在服务端response http流实现后端推送消息至前端：前端发起请求，服务端可以推送多次response;一个request对应多个response ajax轮询 需要服务器有很快的处理速度和资源。（速度） long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小） 传统轮询技术(Ajax短轮询)是客户端向服务器发起HTTP请求，无论数据是否更新，服务器都会传输数据。一个request对应一个response。服务器推送技术(Ajax长轮询)是短轮询的变种，是客户端向服务器发起HTTP请求，只有等待数据更新后才会传输数据，否则服务器保持连接状态。接着发起下一次HTTP请求，一个request对应一个response。服务器推送技术(HTTP流)，在客户端只发起一次HTTP请求，服务器保持连接状态，在数据更新之后，服务器会传输数据，否则保持连接状态。此时一个requset对应多个response。无论是短轮询、长轮询，还是HTTP流，相同点在于都需要客户端先发起HTTP请求。 5.3 示例Js webSocketAPI 打开WebSocket, 传递的参数url没有同源策略的限制。1234567891011121314151617181920212223242526let websocket = new WebSocket(url)// 监听open事件，在成功建立websocket时向url发送纯文本字符串数据(如果是对象则必须序列化处理)。websocket.onopen = () =&gt; &#123; if (websocket.readyState === WebSocket.OPEN) &#123; websocket.send(&apos;hello world&apos;) &#125;&#125;// 监听message事件，在服务器响应时接受数据。返回的数据存储在事件对象中。websocket.onmessage = e =&gt; &#123; let data = e.data console.log(data)&#125;// 监听error事件，在发生错误时触发，连接不能持续。websocket.onerror = () =&gt; &#123; console.log(&apos;websocket connecting error!!&apos;)&#125;// 监听close事件，在连接关闭时触发。只有close事件的事件对象拥有额外的信息。可以通过这些信息来查看关闭状态websocket.onclose = e =&gt; &#123; let clean = e.wasClean // 是否已经关闭 let code = e.code // 服务器返回的数值状态码。 let reason = e.reason //服务器返回的消息。&#125; 看完让你彻底搞懂Websocket原理webSocket协议webSocket协议解析golang中的webSocket实现golang官方webSocket实现 6 并发编程 select I/O复用7 前后端通信 前端作为通信的cli端，若http协议只能通过请求获取response 服务端之间通信: 服务端均可作为通信的server端存在 服务端A B B推送消息给A，A作为server端，B作为cli端调用接口(http rpc)发送消息给A； B主动发起请求，获取response A需要从B获取消息: B作为server端提供响应接口，A作为cli端调用B(http rpc)； A主动发起请求获取response 8 其他 IP地址是逻辑地址用来标识网络中的一个主机，ip地址唯一，计算机间通信通过ip IP分公有ip及私有ip，公有ip全球可以访问，私有地址(以192.168.开头)不能直接在internet网络中应用 IP地址=网络地址+主机地址 网络地址就是判断网络中的计算机在不在同一网络,在就能通,不在就不能通 网络地址: IP地址&amp;子网掩码，二进制计算获取网络地址 域名internet中计算机或者计算机组的名称,域名便于人类记忆 DNS(Domain name server): 域名服务器，存有域名跟ip的对应表，可以将域名解析为ip； chrom浏览器输入google.com：1 请求dns服务器解析google.com获取ip地址 2 与该ip建立连接 用网线直接连接的计算机或是通过HUB（集线器）或普通交换机间接的计算机之间要能够相互通,计算机必须要在同一网络；即网络地址必须相同 网络A的IP地址范围为“192.168.1.1192. 168.1.254”，网络B的IP地址范围为“192.168.2.1192.168.2.254”，两者的子网掩码为255.255.255.0 网络A与B在不同的网络中不能直接通信，两者必须通过网关通信：如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机 网关的IP地址是具有路由功能的设备的IP地址： 路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。 一台主机可以有多个网关,主机找不到可用网关则使用默认网关 自动设置就是利用DHCP（Dynamic Host Configuration Protocol, 动态主机配置协议）服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关 。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。另外一种自动获得网关的办法是通过安装代理服务器软件（如MS Proxy）的客户端程序来自动获得，其原理和方法和DHCP有相似之处。 IP地址，子网掩码，默认网关，DNS服务器详解]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
        <tag>http1.0-2</tag>
        <tag>webSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go基础整理]]></title>
    <url>%2F2019%2F06%2F20%2Fgo-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1 go方法 方法分为方法类型及方法值 方法类型：方法接收器的类型+方法名 方法值：方法接收器+方法名 方法类型及方法值均可以直接作为函数调用，方法类型函数调用时第一个参数为接收器类型，类型不会自动转换 方法值直接定义了接收器，接收器类型可自动转换，方法接收器的类型的实质不可以为指针或者interface；字面量取不到对应地址 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt")type test struct&#123;a intb int&#125;func main() &#123; fmt.Println("Hello, playground") b := test&#123;2,2&#125; b.show("直接调用") // 1 方法表达式 c := test.show // 方法表达式 c(b,"方法表达式调用") // 调用方法表达式需要指定接收器 // 2 方法的值 d := b.show // 或者(&amp;b).show 方法值调用自动指定接收器，类型可自动转换 d("方法值调用方式") // 方法指针 e := (*test).show1 // 方法表达式 为指针 e(&amp;b, "方法表达式调用") // 接收器为指针，不会自动转换 f := (&amp;b).show1 // 或者b.show1 f("方法值调用") &#125;func (a test) show(b string)&#123;fmt.Printf("%s: %+v\n",b, a)&#125;// 不可重名func (a *test) show1(b string)&#123;a.a=1fmt.Printf("%s: pointer %+v\n",b, *a)&#125; 2 go接口 接口定义了规约 接口定义方法签名，interface{}类型为interface{}类型只是任意类型均实现了该接口，会隐士转换类型 接口值包括type&amp;&amp;value 接口为nil为接口值的type&amp;&amp;value均为nil 接口值的type类型必须实现接口对应的方法；go语言为静态语言，编译时无法知道接口的动态类型，？？？？接口的编译 接口初始化时会判定相应的初始化时是否实现了接口类型 接口的实现为指针时，接口初始化值不可以为变量必须为指针(go传参数为值copy类型) 接口的实现为值时，接口初始化可以为指针也可以为变量，指针可以隐士解引获取对应的底层变量 接口详细介绍及底层实现 接口隐士实现：实现即接口 看代码：flag及sort的实现 示例： 1234567891011121314151617181920212223242526272829package mainimport ( "fmt")type testInterface interface&#123;set(a string)show()&#125;type testHello struct&#123;info string&#125;func (a *testHello) set(b string)&#123;a.info=b&#125;func (a *testHello) show()&#123;fmt.Println("here is: ", a.info)&#125;func main() &#123; var hello testHello hello.info="123" var testType testInterface = &amp;hello //接口类型为testInterface,接口值为动态变量的类型及值，接口的值分为type&amp;&amp;value //接口值： 1 type=*testHello 2 value=&amp;hello；接口值中type必须实现接口定义的方法 // testInterface=hello错误 //cannot use hello (type testHello) as type testInterface in assignment: //testHello does not implement testInterface (set method has pointer receiver) testType.set("hello world") testType.show() fmt.Printf("%T",hello)&#125; 123456789101112131415161718192021package mainimport ( "fmt")type testInterface interface&#123;show()&#125;type testHello struct&#123;info string&#125;func (a testHello) show()&#123;fmt.Println("here is: ", a.info)&#125;func main() &#123; var hello testHello hello.info="123" var testType testInterface = &amp;hello //接收类型为非指针类型，interface值的type可以为指针也可以为非指针 testType.show() fmt.Printf("%T",hello)&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot整理]]></title>
    <url>%2F2019%2F06%2F17%2Fspring-boot%2F</url>
    <content type="text"><![CDATA[SpringBoot Issues springboot正常启动访问404 ：Springboot会自动扫描启动类同级包及其同级包的子包所有的注解。如果想自己控制扫描哪些包的话，使用@componentscan注解，多个包的话使用逗号分隔如：@componentscan(“com.package1,cn.package2”) 用法 配置文件，参数配置,参数引用 变量配置:resource中配置两个文件application.properties &amp;&amp; application-dev.properties; 分配配置端口server.port为8081 &amp;&amp; 8088 java运行命令： java -Dspring.profiles.active=dev -jar target/XXXX.jar 或者 java -jar XX.jar –spring.profiles.active=dev 实际运行端口为application-dev.properties文件中的配置 参数引用：通过@Value将私有变量value1定义为配置文件中com.test.rand对应值 com.example.web;123456789101112import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.RequestMapping; @RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;com.test.rand&#125;&quot;) private String value1; @RequestMapping(&quot;/hello&quot;) public String index()&#123; return value1; &#125;&#125; spring DI spring可以注入class注册到bean spring bean可以由xml文件定义bean 应用程序支持spring注解需要配置app-context-annotation.xml文件,告诉spring扫描代码，找到@Component @Controller @Respository @Service注解的注入bean以及支持在指定包（及所有子包）下使用@Autowired @Inject @Resource注解的beanxml文件配置可以被java配置替代(如下代码中的@Configuration) 123// app-context-annotation.xml文件:&lt;context:componet-scan base-package="com.apress.prospring5.ch3.annotation"/&gt; app-context-xml.xml文件: 12345 &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; java配置 1234567891011121314151617181920212223// 注解配置，ctx直接调用该配置，通过bean可以自动实现interface// 该配置可以获取provider及renderer interface// java配置可以同过xml文件注入eg: @ImportResource(locations = &#123;"classpath:spring/app-context-xml.xml"&#125;)@ComponentScan(basePackages = &#123;"com.apress.prospring5.ch3.annotation) //必须启动组建扫描@Configurationpublic class HelloWorldConfiguration&#123; @Bean public MessageProvider provider() &#123; return new HelloWorldMessageProvoder(); // provider具体实现class &#125; @Bean public MessageRenderer renderer()&#123; // renderer的具体实现class MessageRenderer renderer = new StandardOutMessageRenderer(); renderer.setMessageProvider(provider()); return renderer; &#125;&#125;// 以上配置替代app-context-xml.xml文件: &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; setter注入中指定标记（每个标记注入一个依赖项）代码片段如下: 123456&lt;bean id="renderer" class=.....StandardOutMessageRenderer"&gt; &lt;property name="messageProvider" ref="provider"/&gt;&lt;/bean&gt;&lt;bean id="provider"class=....HelloWorldMessageProvider/&gt; spring2.5以上： 12345 &lt;bean id="provider"class=....HelloWorldMessageProvider/&gt;&lt;bean id="renderer"class=.....StandardOutMessageRenderer"p:messageProvider-ref="provider"/&gt; setter注入注解方式： 12345678@Service("renderer")public class StandardOutMessageRenderer implements MessageRenderer&#123; @Overrider @Autowired //可使用@Resource(name="messageProvider") public void setMessageProvider(MessageProvoder provoder)&#123; this.messageProvider = provider; &#125;&#125; 构造函数注入 12345678910public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; public ConfigurableMessageProvider(String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 创建ConfigurableMessageProvider需要提供非null的消息值，重定义xml创建实例，使用构造函数注入消息: 1234 &lt;bean id="messageProvider"class=....ConfigurableMessageProvider/&gt;&lt;constructonr-arg type="String" value="I hope..."/&gt;&lt;/bean&gt; 多个构造函数使用indexSpring3.1起参数可以用c名称空间，即 123&lt;constructonr-arg value="I hope..."/&gt;&lt;/bean&gt;修改为：c:message="I I hope..." 构造函数使用注解： 123456789101112public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; // @Value能注入值 @AutoWired public ConfigurableMessageProvider(@Value("configurable message") String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 1234567891011121314151617181920将@Value变为外部文件注入xml文件变为：&lt;context:componet-scan base-package="com.apress.prospring5.ch3.annotation"/&gt; &lt;bean id="message" class="java.lang.String" c:_0="I hope ..."/&gt;其中c:_0中_0为索引对应代码为：构造函数中value会由bean自动注入public class ConfigurableMessageProvider implements MessageProvider &#123; private String message; // @Value能注入值 @AutoWired public ConfigurableMessageProvider(String message)&#123; this.message=message; &#125; @Overrider public String getMessage()&#123; return message; &#125;&#125; 通过注解指定用于构造的构造方法: 12345678910111213141516171819202122@Servicepublic class ConstructorConfusion()&#123;private String somevaluepublic void ConstructorConfusion(String somevalue)&#123; System.out.println("ConstructorConfusion(string) called"); this.somevalue=somevalue;&#125;@Autowired //指定了构造函数，只能用于一个public void ConstructorConfusion(int somevalue)&#123; System.out.println("ConstructorConfusion(int) called"); this.somevalue="Number: "+Integer.toString(somevalue);&#125;public String toString()&#123; return somevalue;&#125;public static void main(String... args)&#123;GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-annotation.xml");ctx.refresh();ConstructorConfusion cc=(ConstructorConfusion)ctx.getBean("constructorConfusion");System.out.println(cc);ctx.close(); 字段注入:依赖直接注入字段，不需要构造函数及setter,通过@Autowired 不能用于final字段，只能通过构造函数 注入参数 setter与构造函数分别通过及标记注入示例如下： 12345678910111213141516171819202122232425262728293031public class InjectSimple &#123;prviate String name;private int age;private float height;public static void main(String... args)&#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-xml.xml");ctx.refresh();InjectSimple simple = (InjectSimple)ctx.getBean("injectSimple");System.out.println(simple);ctx.close();&#125;public void setAge(String age)&#123; this.age=age;&#125;public void setName(String name)&#123; this.name=name;&#125;public void setHeight(float height)&#123; this.height=height;&#125;app-context-xml.xml&lt;beans ...&gt; &lt;bean id="injectSimpleConfig" class="com.apress.prospring5.ch3.xml.InjectSimpleConfig"/&gt; &lt;bean id="injectSimpleSpel" class="com.apress.prospring5.ch3.xml.InjectSimpleSpel" p:name="xx" p:age="123" p:height="1.1"/&gt;&lt;/beans&gt; 注解方式: 12345678910111213141516171819202122232425@Service("injectSimple") //或者spel注入@Service("injectSimpleSpel")public class InjectSimple &#123;@Value("xx") //或者spel注入 @Value("#&#123;injectSimpleConfig.name&#125;")prviate String name;@Value("11") //或者spel注入 @Value("#&#123;injectSimpleConfig.age +1 &#125;")private int age;@Value("1.1")private float height;public static void main(String... args)&#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();ctx.load(""classpath:spring/app-context-xml.xml");ctx.refresh();InjectSimple simple = (InjectSimple)ctx.getBean("injectSimple");System.out.println(simple);ctx.close();&#125;public void setAge(String age)&#123; this.age=age;&#125;public void setName(String name)&#123; this.name=name;&#125;public void setHeight(float height)&#123; this.height=height;&#125; 123456789101112131415161718192021//调用方式：// 1 xml文件配置publci class DeclareSpringComponents &#123; GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // A、加载app-context-annotation.xml文件 告知spring扫描代码找到注解, interface的具体实现class必须带注解;使用annotation包中注解定义的bean // B、 加载app-context-xml.xml ctx.load("classpath:spring/app-context-xml.xml);//可以将app-context-xml.xml 替换为app-context-annotation.xml，只要class的实现添加了注解，则两者实现完全一致 ctx.refresh(); MessageRenderer messageRenderer = ctx.getBean("renderer", MessageRenderer.class); messageRenderer.render(); ctx.close();&#125;// 2 配置类public class HelloWorldAnnotated &#123; public static void main(String... args) &#123; // 加载配置类 ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfiguration.class); MessageRenderer messageRenderer = ctx.getBean("renderer", MessageRenderer.class); messageRenderer.render(); spring框架主要：interface + DI (dependency injection) 通过applicationContext获取interface的具体实现class，通过ctx.getbean自动实现interface，spring 框架自动处理 setter注入，java 配置， 构造函数实现 java配置 10 参考查询spring注解]]></content>
      <tags>
        <tag>java, spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础整理]]></title>
    <url>%2F2019%2F06%2F14%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java基础 序列化 将对象的状态信息转化为可以存储或者传输的形式的过程 储存媒介档案、记忆缓冲体；网络传输中为：字节或者xml文件 反序列化存储形式还原为对象 创建的对象在jvm的stack中，jvm停止对象消失，序列化持久对象需要的时候反序列化恢复 应用场景: RMI(远程方法调用)及网络传输 API接口：java.io.Serializable &amp;&amp; java.io.Externalizable 序列化时，并不保存静态变量: 序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量 Transient关键字: 控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值 Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。若不定义这两个方法的实现细节，则输出的内容为空。 在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。 java编译&amp;&amp;运行 javac将java程序编译成二进制字节码class jvm虚拟机：加载class 编译成机器码(JIT编译时运行动态编译，AOT先编译后运行) 内存管理 java为跨平台语言，运行在jvm虚拟机上，虚拟机本身处理不同操作系统平台问题 JIT编译&amp;&amp;运行节省空间效率低，编译跟运行共分资源影响运行； AOT编译完运行，占用空间，运行效率高 JIT VS AOTjava虚拟机java基础 jvm vs vmWare jvm是虚拟进程：程序计数 内存管理 虚拟cpu 启动不同的java程序会启动不同的jvm进程 java程序依赖与jvm进程 vmWare为虚拟机器: 进程管理 i/o cpu 网络i/o [vmWare vs docker] (https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-virtual-machine) docker应用打包：资源隔离 应用打包 应用依赖 应用的环境变量等 docker虚拟操作系统共享内核 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。 docker Docker 是世界领先的软件容器平台。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于 LXC. Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。 用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 java注解&amp;&amp;反射 注解类似标签不是程序，通过反射可以获取注解，obj.getclass 利用class获取类中成员 方法 类本身等的注解 注解可以定义期时间周期 反射获取类信息 方法等，方法可以通过invoke执行对应的方法 invoke示例 代码类似如下： 主入口： tags.*;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;@SuppressWarnings(&quot;deprecation&quot;)@TestAnnotation()public class MyAnnotation &#123; @Check int a; @Perform public void testMethod()&#123;&#125;; @SuppressWarnings(&quot;deprecation&quot;) public void test1()&#123; Hero myHero = new Hero(); myHero.speak(); myHero.speak(); int b = a; System.out.println(b); &#125; private int test2(int c, int d)&#123; return c+d; &#125; public MyAnnotation(int ...b )&#123; a=b[0]; &#125; public static void main(String[] args)&#123; boolean ifAnnotation = MyAnnotation.class.isAnnotationPresent(TestAnnotation.class); if (ifAnnotation)&#123; TestAnnotation testAnnotation = MyAnnotation.class.getAnnotation(TestAnnotation.class); System.out.println(&quot;the id of annotation is: &quot;+testAnnotation.id()); System.out.println(&quot;the string of annnotaion is: &quot; + testAnnotation.msg()); &#125; MyAnnotation myTest = new MyAnnotation(1,2); Class myClass = myTest.getClass(); Field[] myFields = myClass.getDeclaredFields(); for (Field myField : myFields)&#123; System.out.println(myField); &#125; Method[] methods = myClass.getDeclaredMethods(); // 示例method.invoke // methodXX.invoke(Object obj, Object ...args)利用指定的参数args执行指定对象obj中该方法，返回值为object型 for (Method method : methods)&#123; if (method.getName()==&quot;test2&quot;) &#123; try &#123;System.out.println(&quot;res of invoke: &quot;+ method.invoke(myTest, new Object[] &#123;new Integer(10), new Integer(20)&#125;)); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; try &#123; Field a = MyAnnotation.class.getDeclaredField(&quot;a&quot;); a.setAccessible(true); Check check = a.getAnnotation(Check.class); if (check != null) &#123; System.out.println(check.value()); &#125; Constructor[] test = MyAnnotation.class.getConstructors(); int modifiers = test[0].getModifiers(); System.out.println(Modifier.isPrivate(modifiers)); for (Constructor tets : test)&#123; System.out.println(&quot;构造函数是否带参数: &quot;+ tets.isVarArgs()); &#125; &#125;catch (NoSuchFieldException e)&#123; e.printStackTrace(); &#125;catch (SecurityException e)&#123; e.printStackTrace(); &#125; &#125;&#125; package tags 12345678910111213141516171819202122232425262728293031323334353637383940package tags;public @interface Check &#123; //注解的属性 名为value类型为string默认值为"hi" String value() default "hi";&#125;package tags;public class Hero &#123; @Deprecated() public void say()&#123; System.out.println("Noting has to say!"); &#125; public void speak()&#123; System.out.println("I have a dream!"); &#125;&#125;package tags;public @interface Perform &#123;&#125;package tags;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//target为基本注解限定注解可以使用的范围@Target(ElementType.TYPE)// retention限定注解的生命周期@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id() default 1; String msg() default "hi";&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 内存]]></title>
    <url>%2F2019%2F06%2F14%2Fgo_mem%2F</url>
    <content type="text"><![CDATA[go内存模型 内存模型剖析 待补充 逃逸分析 编译参数加入 -gcflags ‘-m -l’ go消除堆栈区别 逃逸分析确定变量的储存区域为堆/栈，减少gc压力，栈可以直接回收，栈分配空间及回收空间较快 代码段 main12345678910111213141516171819202122import ( &quot;time&quot; &quot;fmt&quot;)func main()&#123; //go_parser.TestParser(&quot;a==1 &amp;&amp; b!=2&quot;) res := make(map[string]int) fmt.Println(res[&quot;res&quot;]) fmt.Println(int(time.Now().Weekday())) // test grpc dispatch get scenes //grpc.GetScene(20351, imkfdispatch.Scene_BuyCarConsult) res1 := taoyi() fmt.Println(&quot;2st addr of i: &quot;, res1) i := *res1 fmt.Println(&quot;the res is: %d&quot;, i) fmt.Println(&quot;3st addr of i: &quot;, &amp;i)&#125;func taoyi()(*int)&#123; var i int = 1 fmt.Println(&quot;1st addr of i: &quot;, &amp;i) return &amp;i&#125; 输出内容： ./main.go:25:14: “1st addr of i: “ escapes to heap./main.go:25:33: &amp;i escapes to heap./main.go:25:33: &amp;i escapes to heap./main.go:24:6: moved to heap: i./main.go:26:9: &amp;i escapes to heap./main.go:25:13: taoyi … argument does not escape./main.go:11:17: res[“res”] escapes to heap./main.go:13:17: int(time.Now().Weekday()) escapes to heap./main.go:17:14: “2st addr of i: “ escapes to heap./main.go:17:14: res1 escapes to heap./main.go:19:14: “the res is: %d” escapes to heap./main.go:19:14: i escapes to heap./main.go:20:14: “3st addr of i: “ escapes to heap./main.go:20:33: &amp;i escapes to heap./main.go:20:33: &amp;i escapes to heap./main.go:18:2: moved to heap: i./main.go:10:13: main make(map[string]int) does not escape./main.go:11:13: main … argument does not escape./main.go:13:13: main … argument does not escape./main.go:17:13: main … argument does not escape./main.go:19:13: main … argument does not escape./main.go:20:13: main … argument does not escape 参考1]]></content>
      <tags>
        <tag>go,内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常处理]]></title>
    <url>%2F2019%2F06%2F12%2Fjava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1 自定义异常]]></content>
      <tags>
        <tag>java, 异常</tag>
      </tags>
  </entry>
</search>
